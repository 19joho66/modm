#!/usr/bin/env python
# 
# Copyright (c) 2009, Roboterclub Aachen e.V.
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Roboterclub Aachen e.V. nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# $Id$

import os
import re
import datetime

# -----------------------------------------------------------------------------
# prepare environment

Import('env')
Import('sources')
Import('header')
Import('library')

env = env.Clone()
env.Append(CPPPATH = '../../src')

# -----------------------------------------------------------------------------
# create a function scanner

class Scanner:
	# FIXME correct handling of strings and comments
	commentFilter = re.compile(r"/\*.*?\*/", re.DOTALL)
	
	# find any function 'void test*();'
	functionFilter = re.compile(r"void\s+(test[A-Z]\w*)\s*\([\svoid]*\)\s*;")
	
	def __init__(self, text):
		self.text = text
	
	def getFunctions(self):
		self._stripCommentsAndStrings()
		functions = self.functionFilter.findall(self.text)
		return functions
	
	def _stripCommentsAndStrings(self):
		self._prepareString()
		self._stripComments()
		
		lines = self.text.splitlines()
		for i, line in enumerate(lines):
			lines[i] = self._stripCppComments(line)
		
		self.text = '\n'.join(lines)
	
	def _prepareString(self):
		self.text = self.text.replace('\r\n', '\n')
		self.text = self.text.replace('\\\n', '')
	
	def _stripCppComments(self, line):
		index = line.find(r"//")
		if index >= 0:
			return line[:index]
		return line
	
	def _stripComments(self):
		self.text = self.commentFilter.sub('', self.text)

# -----------------------------------------------------------------------------
# find all header files named '*_test.hpp' and extract the function names

tests = {}
for file in header:
	filename = file.name
	if filename.endswith('_test.hpp'):
		sourceFile = filename[:-3] + 'cpp'
		
		if sourceFile not in sources:
			print "WARNING: found header '%s' without a corresponding source file!"
			continue
		
		# io_stream_test -> IoStreamTest
		className = file.basename.title().replace('_', '')
		scanner = Scanner(open(file.abspath).read())
		
		tests[className] = {
			'includePath': filename,
			'functions': scanner.getFunctions(),
			'testName': sourceFile,	#file.basename,
		}

# -----------------------------------------------------------------------------
# create the runner file

includes = []
nameStrings = []
testsCases = []
for className, attr in tests.iteritems():
	includes.append('#include "%s"' % attr['includePath'])
	
	instanceName = className[0].lower() + className[1:]
	testNameString = instanceName + 'Name'
	nameStrings.append('FLASH_STRING(%s) = "%s";' % (testNameString, attr['testName']))
	
	str = """
	unittest::Controller::instance().nextTestSuite(xpcc::Flash(%s));
	{
		%s %s;
		""" % (testNameString, className, instanceName)
	
	for functionName in attr['functions']:
		str += """
		%(instance)s.setUp();
		%(instance)s.%(function)s();
		%(instance)s.tearDown();
		""" % { 'instance': instanceName, 'function': functionName }
	
	str += "}"
	
	testsCases.append(str)

substitutions = {
	'iodeviceInclude': '#include <xpcc/io/backplane/std/std_iodevice.hpp>',
	'includes': '\n'.join(includes),
	'nameStrings': 'namespace\n{\n\t%s\n}' % '\n\t'.join(nameStrings),
	'iodevice': 'xpcc::StdIODevice',
	'tests': '\n'.join(testsCases),
}

runnerFile = env.Template('main.cpp.in', SUBSTITUTIONS=substitutions)
env.AlwaysBuild(runnerFile)		# TODO replace this with real dependencies

# -----------------------------------------------------------------------------
# compile the source files

objects = [env.Object(runnerFile)]
for file in sources:
	object = env.Object(file.name,
						CPPDEFINES=file.getDefines(env.get('CPPDEFINES', {})))
	objects.append(object)

program = env.Program('unittest', objects,
						LIBS=['robot'] + env['LIBS'],
						LIBPATH=env['LIBPATH'] + ['../../build/lib'])

# -----------------------------------------------------------------------------
# run the unit tests

if env['ARCHITECTURE'] == 'pc':
	if int(ARGUMENTS.get('run', 1)):
		env.Command('thisfileshouldnotexist', program, './build/unittest/unittest') 
else:
	env.Hex(program)
	env.Listing(program)
