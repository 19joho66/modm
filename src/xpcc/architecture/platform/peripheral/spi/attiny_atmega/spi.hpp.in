// coding: utf-8
// ----------------------------------------------------------------------------
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Roboterclub Aachen e.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// ----------------------------------------------------------------------------

#ifndef XPCC_{{target.family | upper}}__SPI_HPP
#define XPCC_{{target.family | upper}}__SPI_HPP

#include "../../../device.hpp"
#include <xpcc/architecture/peripheral/spi.hpp>

namespace xpcc
{
	namespace {{target.family}}
	{
		struct Spi
		{
			enum class Mode : uint8_t
			{
				Mode0 = 0,							///< SCK normal,	sample on rising edge
				Mode1 = (1 << CPHA),				///< SCK normal,	sample on falling edge
				Mode2 = (1 << CPOL),				///< SCK inverted,	sample on falling edge
				Mode3 = (1 << CPOL) | (1 << CPHA),	///< SCK inverted,	sample on rising edge
			};

			enum class Prescaler : uint8_t
			{
				Div2 = 0x80 | 0,
				Div4 = 0,
				Div8 = 0x80 | (1 << SPR0),
				Div16 = (1 << SPR0),
				Div32 = 0x80 | (1 << SPR1),
				Div64 = (1 << SPR1),
				Div128 = (1 << SPR1) | (1 << SPR0),
			};

			enum class BufferOptions : uint8_t
			{
				TxRxIncrement = 0b11,
				TxIncrementRxDecrement = 0b10,
				TxDecrementRxIncrement = 0b01,
				TxRxDecrement = 0b00,
			};

			%% for gpio in gpios
			typedef ::xpcc::{{target.family}}::Gpio{{ gpio.port }}{{ gpio.id }} {{ gpio.name | capitalize }};
			%% endfor
		};

		/**
		 * \brief		Spi Master
		 *
		 * The fast SPI clock speeds make it unreasonable to use an interrupt
		 * based approach to shifting out each byte of the data, since the interrupt
		 * handling might decrease performance over busy waiting especially for
		 * targets operating at low CPU frequencies.
		 *
		 * Therefore the asynchronous methods are implemented synchronously.
		 *
		 * \ingroup		{{target.family}}
		 * \author		Niklas Hauser
		 */
		class SpiMaster : public xpcc::SpiMaster, Spi
		{
		public:
			/**
			 * \brief	Initialize SPI module
			 * 
			 * This also sets the directions of the I/O pins.
			 */
			static void
			initialize(Mode mode, Prescaler prescaler)
			{
				SPCR = (1 << SPE) | (1 << MSTR) | (static_cast<uint8_t>(prescaler) & ~0x80) | static_cast<uint8_t>(mode);
				SPSR = (static_cast<uint8_t>(prescaler) & 0x80) ? (1 << SPI2X) : 0;
				%% for io in gpios
				%% if io.name == 'miso'
				Miso::setInput();
				%% elif io.name == 'mosi'
				Mosi::setOutput();
				%% elif io.name == 'sck'
				Sck::setOutput();
				%% elif io.name == 'ss'
				Ss::setOutput();
				%% endif
				%% endfor
			}

			static uint8_t
			writeReadBlocking(uint8_t data)
			{
				SPDR = data;

				while(!isFinished())
					;
				return getResult();
			}

			static void
			writeBlocking(uint8_t data)
			{
				SPDR = data;

				while(!isFinished())
					;
			}

			static ALWAYS_INLINE bool
			write(uint8_t data)
			{
				if (!isFinished())
					return false;

				SPDR = data;
				return true;
			}

			static ALWAYS_INLINE uint8_t
			getResult()
			{
				uint8_t data = SPDR;
				return data;
			}

			static ALWAYS_INLINE bool
			isFinished()
			{
				return (SPSR & (1 << SPIF));
			}
		};

		/**
		 * \brief		Spi Master with DMA support
		 *
		 * Since the AVR architecture of the ATmega and ATtiny does not have DMA support,
		 * these methods are implemented as blocking using busy waiting.
		 *
		 * \ingroup		{{target.family}}
		 * \author		Niklas Hauser
		 */
		class SpiBlockMaster : public xpcc::SpiBlockMaster, Spi
		{
		public:
			/**
			 * \brief	Initialize SPI module
			 *
			 * This also sets the directions of the I/O pins.
			 */
			static ALWAYS_INLINE void
			initialize(Mode mode, Prescaler prescaler)
			{
				SpiMaster::initialize(mode, prescaler);
				finished = true;
			}

			static inline bool
			start(uint8_t * tx, uint8_t * rx, std::size_t length, BufferOptions options=BufferOptions::TxRxIncrement)
			{
				if (!isFinished())
					return false;

				finished = false;

				uint8_t tx_byte = 0xff;
				uint8_t rx_byte;

				for (std::size_t i = 0; i < length; i++)
				{
					if (tx) tx_byte = tx[static_cast<uint8_t>(options) & 0b10 ? i : length-i-1];

					rx_byte = SpiMaster::writeReadBlocking(tx_byte);

					if (rx) rx[static_cast<uint8_t>(options) & 0b01 ? i : length-i-1] = rx_byte;
				}

				finished = true;
				return true;
			}

			static ALWAYS_INLINE bool
			isFinished()
			{
				return finished;
			}
			
		private:
			static bool finished;
		};
	}
}

#endif
