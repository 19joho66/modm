// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
* All Rights Reserved.
*
* The file is part of the xpcc library and is released under the 3-clause BSD
* license. See the file `LICENSE` for the full license governing this code.
*/
// ----------------------------------------------------------------------------

#ifndef XPCC_STM32_SIMPLE_SPI{{ id }}_HPP
#	error	"Don't include this file directly, use 'simple_spi.hpp' instead!"
#endif

// ----------------------------------------------------------------------------
template< class clockSource, uint32_t baudrate, xpcc::Tolerance tolerance >
void ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::initialize()
{
	static_assert(clockSource::Spi{{ id }}/2 >= baudrate,
		"The peripheral frequency must be at least 2x higher than SPI baudrate.");
	static_assert(clockSource::Spi{{ id }}/256 <= baudrate,
		"The SPI baudrate must be at most 256x lower than peripheral frequency.");

	constexpr uint16_t pre_raw = (clockSource::Spi{{ id }} / baudrate);
	// check if within baudrate tolerance
	constexpr uint32_t generated_baudrate = clockSource::Spi{{ id }} / pre_raw;
	constexpr uint32_t error = baudrate - generated_baudrate;
	static_assert(error <= baudrate * (static_cast<float>(tolerance) / 100),
			"The generated SPI baudrate is outside of specified tolerance.");

	// constexpr has some limitations, this is a compact if else tree
	constexpr SpiHal{{ id }}::Prescaler prescaler = (
			(pre_raw >= 256) ? SpiHal{{ id }}::Prescaler::Div256 : (
			(pre_raw >= 128) ? SpiHal{{ id }}::Prescaler::Div128 : (
			(pre_raw >=  64) ? SpiHal{{ id }}::Prescaler::Div64  : (
			(pre_raw >=  32) ? SpiHal{{ id }}::Prescaler::Div32  : (
			(pre_raw >=  16) ? SpiHal{{ id }}::Prescaler::Div16  : (
			(pre_raw >=   8) ? SpiHal{{ id }}::Prescaler::Div8   : (
			(pre_raw >=   4) ? SpiHal{{ id }}::Prescaler::Div4   :
			SpiHal{{ id }}::Prescaler::Div2
			)))))));

	SpiHal{{ id }}::initialize(prescaler);
	finished = true;
}

void ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::setDataMode(DataMode mode)
{
	SpiHal{{ id }}::setDataMode(static_cast<SpiHal{{ id }}::DataMode>(mode));
}

void ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::setDataOrder(DataOrder order)
{
	SpiHal{{ id }}::setDataOrder(static_cast<SpiHal{{ id }}::DataOrder>(order));
}

uint8_t ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::writeReadBlocking(uint8_t data)
{
	writeBlocking(data);
	while(!getResult(data))
		;
	return data;
}

void ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::writeBlocking(uint8_t data)
{
	while(!isFinished())
		;
	SpiHal{{ id }}::write(data);
}

bool ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::write(uint8_t data)
{
	if(!isFinished())
		return false;

	SpiHal{{ id }}::write(data);
	return true;
}

bool ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::getResult(uint8_t &data)
{
	if (!SpiHal{{ id }}::isReceiveRegisterNotEmpty())
		return false;

	SpiHal{{ id }}::read(data);
	return true;
}

bool ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::isFinished()
{
	return SpiHal{{ id }}::isTransmitRegisterEmpty() && finished;
}
