// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
* All Rights Reserved.
*
* The file is part of the xpcc library and is released under the 3-clause BSD
* license. See the file `LICENSE` for the full license governing this code.
*/
// ----------------------------------------------------------------------------
#include "spi_{{ id }}.hpp"

void
xpcc::stm32::SimpleSpiMaster{{ id }}::setDataMode(DataMode mode)
{
	Spi{{ id }}::setDataMode(static_cast<Spi{{ id }}::DataMode>(mode));
}

void
xpcc::stm32::SimpleSpiMaster{{ id }}::setDataOrder(DataOrder order)
{
	if(order == DataOrder::MsbFirst) {
		Spi{{ id }}::setDataOrder(Spi{{ id }}::DataOrder::MsbFirst);
	} else {
		Spi{{ id }}::setDataOrder(Spi{{ id }}::DataOrder::LsbFirst);
	}
}

uint8_t
xpcc::stm32::SimpleSpiMaster{{ id }}::writeReadBlocking(uint8_t data)
{
	writeBlocking(data);
	while(!Spi{{ id }}::isReceiveRegisterNotEmpty());
	return getResult();
}

void
xpcc::stm32::SimpleSpiMaster{{ id }}::writeBlocking(uint8_t data)
{
	while(!Spi{{ id }}::isTransmitRegisterEmpty());
	Spi{{ id }}::write(data);
}

bool
xpcc::stm32::SimpleSpiMaster{{ id }}::write(uint8_t data)
{
	if(Spi{{ id }}::isTransmitRegisterEmpty()){
		Spi{{ id }}::write(data);
		return true;
	} else {
		return false;
	}
}

uint8_t
xpcc::stm32::SimpleSpiMaster{{ id }}::getResult()
{
	uint8_t data;
	Spi{{ id }}::read(data);
	return data;
}

bool
xpcc::stm32::SimpleSpiMaster{{ id }}::transfer(uint8_t * tx, uint8_t * rx, std::size_t length, BufferOptions options )
{
	int_fast8_t tx_step, rx_step;
	switch(options)
	{
	case BufferOptions::TxRxIncrement:
		tx_step =  1;
		rx_step =  1;
		break;
	case BufferOptions::TxIncrementRxDecrement:
		tx_step =  1;
		rx_step = -1;
		break;
	case BufferOptions::TxDecrementRxIncrement:
		tx_step = -1;
		rx_step =  1;
		break;
	case BufferOptions::TxRxDecrement:
		tx_step = -1;
		rx_step = -1;
		break;
	default:
		tx_step =  1;
		rx_step =  1;
		break;
	}

	uint8_t * tx_stop = tx + (length * tx_step);

	while(tx != tx_stop){
		*rx = writeReadBlocking(*tx);
		tx += tx_step;
		rx += rx_step;
	}

	return true;
}

bool
xpcc::stm32::SimpleSpiMaster{{ id }}::isFinished()
{
	return Spi{{ id }}::isTransmitRegisterEmpty();
}
