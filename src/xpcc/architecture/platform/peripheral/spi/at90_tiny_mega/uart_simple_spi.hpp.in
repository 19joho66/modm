// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
{{ generation_block }}

#ifndef XPCC_{{target.family | upper}}_SIMPLE_UART_SPI{{id}}_HPP
#define XPCC_{{target.family | upper}}_SIMPLE_UART_SPI{{id}}_HPP

#include "../../../device.hpp"
//#include "../../../drivers.hpp"
#include "../../uart/at90_tiny_mega/uart_defines.h"
#include <xpcc/architecture/peripheral/spi.hpp>
#include "type_ids.hpp"

namespace xpcc
{
namespace {{target.family}}
{
	
struct Spi{{id}}
{
%% for gpio in gpios
//typedef ::xpcc::{{target.family}}::Gpio{{ gpio.port }}{{ gpio.id }} {{ gpio.name | capitalize }};
%% endfor
};

/**
 * Implementation of the SimpleSpi of the Uart in Spi Master mode.
 *
 * The fast SPI clock speeds make it unreasonable to use an interrupt
 * based approach to shifting out each byte of the data, since the interrupt
 * handling might decrease performance over busy waiting especially for
 * targets operating at low CPU frequencies.
 * Therefore the asynchronous methods are implemented synchronously.
 *
 * \ingroup		{{target.family}}
 * \author		Niklas Hauser
 */
class UartSimpleSpi{{id}} : public ::xpcc::SimpleSpi, Spi{{id}}
{
public:
	static const TypeId::UartSpiMaster{{ id }} Id;
	
public:
	/**
	 * Enable and initialize the SPI hardware.
	 * The prescaler is calculated as best effort with possible error.
	 *
	 * @tparam	baudrate
	 *		baudrate in Hz
	 * @param	mode
	 *		operation mode
	 */
	template< uint32_t baudrate >
	static inline void
	initialize(Mode mode=Mode::Mode0);

	// start documentation inherited
	static ALWAYS_INLINE uint8_t
	writeReadBlocking(uint8_t data);

	static ALWAYS_INLINE void
	writeBlocking(uint8_t data);

	static ALWAYS_INLINE bool
	write(uint8_t data);

	static ALWAYS_INLINE uint8_t
	getResult();

	static inline bool
	transfer(uint8_t *tx, uint8_t *rx, std::size_t length,
			 BufferOptions options=BufferOptions::TxRxIncrement);

	static ALWAYS_INLINE bool
	isFinished();
	// end documentation inherited

protected:
	static inline void
	initialize(uint16_t prescaler, Mode mode=Mode::Mode0);

private:
	static bool finished;
};

} // namespace {{target.family}}

} // namespace xpcc

#include "uart_simple_spi{{id}}_impl.hpp"

#endif // XPCC_{{target.family | upper}}_SIMPLE_UART_SPI{{id}}_HPP
