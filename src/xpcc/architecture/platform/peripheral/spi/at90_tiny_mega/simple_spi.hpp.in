// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
{{ generation_block }}

#ifndef XPCC_{{target.family | upper}}_SIMPLE_SPI_HPP
#define XPCC_{{target.family | upper}}_SIMPLE_SPI_HPP

#include "../../../device.hpp"
//#include "../../../drivers.hpp"
#include <xpcc/architecture/peripheral/spi.hpp>
#include "type_ids.hpp"
#include "spi.hpp"

namespace xpcc
{

namespace {{target.family}}
{

/**
 * Implementation of a SimpleSpi.
 *
 * The fast SPI clock speeds make it unreasonable to use an interrupt
 * based approach to shifting out each byte of the data, since the interrupt
 * handling might decrease performance over busy waiting especially for
 * targets operating at low CPU frequencies.
 *
 * Therefore the asynchronous methods are implemented synchronously.
 *
 * @ingroup		{{target.family}}
 * @author		Niklas Hauser
 */
class SimpleSpi : public ::xpcc::SimpleSpi, Spi
{
public:
	static const TypeId::SpiMaster Id;
	
	/// Enable and initialize the Spi hardware.
	template< uint32_t baudrate >
	static inline void
	initialize(Mode mode=Mode::Mode0)
	{
		
	}

	static ALWAYS_INLINE uint8_t
	writeReadBlocking(uint8_t data);

	static ALWAYS_INLINE void
	writeBlocking(uint8_t data);

	static ALWAYS_INLINE bool
	write(uint8_t data);

	static ALWAYS_INLINE uint8_t
	getResult();

	static inline bool
	transfer(uint8_t * tx, uint8_t * rx, std::size_t length,
			 BufferOptions options=BufferOptions::TxRxIncrement);

	static ALWAYS_INLINE bool
	isFinished();
	
protected:
	static inline void
	initialize(Prescaler prescaler, Mode mode=Mode::Mode0);
	
private:
	static bool finished;
};

} // namespace {{target.family}}

} // namespace xpcc

#include "simple_spi_impl.hpp"

#endif // XPCC_{{target.family | upper}}_SIMPLE_SPI_HPP
