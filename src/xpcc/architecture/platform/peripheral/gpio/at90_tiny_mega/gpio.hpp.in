// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
{{ generation_block }}

#ifndef XPCC_{{target.family | upper}}__GPIO_HPP
#define XPCC_{{target.family | upper}}__GPIO_HPP

#include "../../../device.hpp"
#include "gpio_define.h"
#include <xpcc/architecture/peripheral/gpio.hpp>


namespace xpcc
{

namespace {{target.family}}
{

struct Gpio
{
	/**
	 * Each Pin can be configured in one of these states.
	 * Only available for Pins configured as inputs!
	 *
	 * @ingroup	{{target.family}}
	 */
	enum class
	Configuration : uint8_t
	{
		Floating,	///< The input pin is left floating
		PullUp,		///< The input pin is pulled to Vcc
	};
	
	/**
	 * Each External Interrupt can be configured to trigger on these conditions.
	 *
	 * @ingroup	{{target.family}}
	 */
	enum class
	InputTrigger : uint8_t
	{
		LowLevel = 0b00,	///< triggers **continously** during low level
		BothEdges = 0b01,	///< triggers on both rising and falling edge
		FallingEdge = 0b10,	///< triggers on falling edge
		RisingEdge = 0b11,	///< triggers on rising edge
	};
};

/**
 * Gpio OpenDrain template, which remaps the behavior of the Gpio pin to
 * simulate an open-drain Output.
 *
 * @ingroup	{{target.family}}
 */
template< class IO >
class GpioOpenDrain : Gpio
{
public:
	/// maps to `setInput(Configuration::PullUp)` 
	ALWAYS_INLINE static void set() {
		IO::setInput(Configuration::PullUp);
	}
	/// maps to `setOutput(::xpcc::Gpio::LOW)`
	ALWAYS_INLINE static void reset() {
		IO::setOutput(::xpcc::Gpio::LOW);
	}
	ALWAYS_INLINE static void set(bool status) {
		if (status) { set(); }
		else { reset(); }
	}
	ALWAYS_INLINE static bool read() {
		return IO::read();
	}
};

/**
 * Gpio Classes created from the XML Device File Gpio Description
 *
 * @ingroup	{{target.family}}
 */
%% for gpio in gpios
	%% set port = gpio.port | upper
	%% set pin  = gpio.id
			
	%% for type in ["Output", "Input", ""] 
		
		%% if type == "Output"
class GpioOutput{{port ~ pin}} : public Gpio, ::xpcc::GpioOutput
		%% elif type == "Input"
class GpioInput{{port ~ pin}} : public Gpio, ::xpcc::GpioInput
		%% elif type == ""
class Gpio{{port ~ pin}} : public Gpio, ::xpcc::GpioIO
		%% endif
{
public:
	static constexpr uint8_t pin = {{pin}};		///< the pin number of this GPIO
	static constexpr uint8_t mask = (1 << pin);	///< the mask of this GPIO
	
		%% if type in ["", "Output"]
	ALWAYS_INLINE static void setOutput(bool status) {
		set(status);
		setOutput();
	}

	ALWAYS_INLINE static void setOutput() {
		DDR{{port}} |= mask;
	}

	ALWAYS_INLINE static void set() {
		PORT{{port}} |= mask;
	}
	
	ALWAYS_INLINE static void set(bool status) {
		if (status) { set(); }
		else { reset(); }
	}

	ALWAYS_INLINE static void reset() {
		PORT{{port}} &= ~mask;
	}

	ALWAYS_INLINE static void toggle() {
		PORT{{port}} ^= mask;
	}
		%% endif
		%% if type in ["", "Input"]
	/// call `setInput()` before calling this method
	ALWAYS_INLINE static void configure(Configuration config) {
		if (config == Configuration::PullUp) {
			PORT{{port}} |= mask;
		}
		else {
			PORT{{port}} &= ~mask;
		}
	}

	ALWAYS_INLINE static void setInput() {
		DDR{{port}} &= ~mask;
	}

	ALWAYS_INLINE static void
	setInput(Configuration config) {
		setInput();
		configure(config);
	}

	ALWAYS_INLINE static bool read() {
		return (PIN{{port}} & mask);
	}
		%% for af in gpio.afs
			%% set af_id = af.id | int
		
			%% if af.type == "extint"
			
			{# Go home Atmel, you're drunk! #}
			%% set eicra = 'EICRA'
			%% set isc2 = ''
			
			%% if target.family == 'atmega' and target.name in ['8', '16', '32', '162', '8515', '8535']
			%% set eicra = 'MCUCR'
			%% if target.name == '162'
			%% set isc2 = 'EMCUCR'
			%% else
			%% set isc2 = 'MCUCSR'
			%% endif
			%% endif
			
	ALWAYS_INLINE static void setInputTrigger(InputTrigger trigger) {
			%% if af_id < 4
				%% if isc2 != '' and af_id == 2
		{{isc2}} |= ((static_cast<uint8_t>(trigger) & 0b01) << ISC2);
				%% else
		{{eicra}} |= (static_cast<uint8_t>(trigger) << 2*{{af_id}});
				%% endif
			%% else
		EICRB |= (static_cast<uint8_t>(trigger) << 2*{{af_id - 4}});
			%% endif
	}
			
	ALWAYS_INLINE static void enableExternalInterrupt() {
#ifdef EIMSK
		EIMSK |= (1 << INT{{af_id}});
#elif defined GIMSK
		GIMSK |= (1 << INT{{af_id}});
#elif defined GICR
		GICR |= (1 << INT{{af_id}});
#else
#	error "Cannot find register for setting INT{{af_id}}!"
#endif
	}

	ALWAYS_INLINE static void disableExternalInterrupt() {
#ifdef EIMSK
		EIMSK &= ~(1 << INT{{af_id}});
#elif defined GIMSK
		GIMSK &= ~(1 << INT{{af_id}});
#elif defined GICR
		GICR &= ~(1 << INT{{af_id}});
#else
#	error "Cannot find register for clearing INT{{af_id}}!"
#endif
	}

	ALWAYS_INLINE static bool readExternalInterruptFlag() {
#ifdef EIFR
		return (EIFR & (1 << INTF{{af_id}}));
#elif defined GIFR
		return (GIFR & (1 << INTF{{af_id}}));
#else
#	error "Cannot find register for reading INTF{{af_id}}!"
#endif
	}

	ALWAYS_INLINE static void acknowledgeExternalInterruptFlag() {
#ifdef EIFR
		EIFR |= (1 << INTF{{af_id}});
#elif defined GIFR
		GIFR |= (1 << INTF{{af_id}});
#else
#	error "Cannot find register for setting INTF{{af_id}}!"
#endif
	}
			%% endif

			%% if af.type == "pcint"

			{# Go home Atmel, you're drunk! #}
			%% if target.family == 'attiny'
			%% if (target.name == '2313' or target.name == '4313') and af_id >= 11 and af_id <= 17
			%% set af_reg = 2
			%% elif (target.name == '20' or target.name == '40' or target.name == '1634') and af_id >= 12 and af_id <= 17
			%% set af_reg = 2
			%% endif
			%% else
			%% set af_reg = (af_id / 8) | int
			%% endif
			
			
	ALWAYS_INLINE static void enablePCInterrupt() {
		PCMSK{{af_reg}} |= (1 << PCINT{{af_id}});
#ifdef PCICR
		PCICR |= (1 << PCIE{{af_reg}});
#elif defined EIMSK
		EIMSK |= (1 << PCIE{{af_reg}});
#elif defined GIMSK
		GIMSK |= (1 << PCIE{{af_reg}});
#elif defined GICR
		GICR |= (1 << PCIE{{af_reg}});
#else
#	error "Cannot find register for setting PCIE{{af_reg}}!"
#endif
	}

	ALWAYS_INLINE static void disablePCInterrupt() {
		PCMSK{{af_reg}} &= ~(1 << PCINT{{af_id}});
		if (!PCMSK{{af_reg}}) {
#ifdef PCICR
			PCICR &= ~(1 << PCIE{{af_reg}});
#elif defined EIMSK
			EIMSK &= ~(1 << PCIE{{af_reg}});
#elif defined GIMSK
			GIMSK &= ~(1 << PCIE{{af_reg}});
#elif defined GICR
			GICR &= ~(1 << PCIE{{af_reg}});
#else
#	error "Cannot find register for clearing PCIE{{af_reg}}!"
#endif
		}
	}

	ALWAYS_INLINE static bool readPCInterruptFlag() {
#ifdef PCIFR
		return (PCIFR & (1 << PCIF{{af_reg}}));
#elif defined EIFR
		return (EIFR & (1 << PCIF{{af_reg}}));
#elif defined GIFR
		return (GIFR & (1 << PCIF{{af_reg}}));
#else
#	error "Cannot find register for reading PCIF{{af_reg}}!"
#endif
	}

	ALWAYS_INLINE static void acknowledgePCInterruptFlag() {
#ifdef PCIFR
		PCIFR |= (1 << PCIF{{af_reg}});
#elif defined EIFR
		EIFR |= (1 << PCIF{{af_reg}});
#elif defined GIFR
		GIFR |= (1 << PCIF{{af_reg}});
#else
#	error "Cannot find register for setting PCIF{{af_reg}}!"
#endif
	}

			%% endif

		%% endfor

		%% endif
};

	%% endfor
%% endfor

%% for nibble in nibbles
	%% set port = nibble.port | upper

	%% for id in nibble.position
		%% if id == 0
struct GpioLowNibble{{port}} : ::xpcc::GpioNibble
{
	ALWAYS_INLINE static void setOutput() {
		DDR{{port}} |= 0x0f;
	}
	ALWAYS_INLINE static void setInput() {
		DDR{{port}} &= ~0x0f;
	}
	ALWAYS_INLINE static uint8_t read() {
		return (PIN{{port}} & 0x0f);
	}
	ALWAYS_INLINE static void write(uint8_t data) {
		PORT{{port}} = (data & 0x0f) | (PORT{{port}} & 0xf0);
	}
};
		%% elif id == 1
struct GpioHighNibble{{port}} : ::xpcc::GpioNibble
{
	ALWAYS_INLINE static void setOutput() {
		DDR{{port}} |= 0xf0;
	}
	ALWAYS_INLINE static void setInput() {
		DDR{{port}} &= ~0xf0;
	}
	ALWAYS_INLINE static uint8_t read() {
		uint8_t data = PIN{{port}};
		return (data >> 4);
	}
	ALWAYS_INLINE static void write(uint8_t data) {
		data <<= 4;
		PORT{{port}} = data | (PORT{{port}} & 0x0f);
	}
};
		%% endif

	%% endfor
%% endfor

%% for octet in octets
	%% set port = octet.port | upper

	%% for id in octet.position
		%% if id == 0
struct GpioPort{{port}} : ::xpcc::GpioOctet
{
	ALWAYS_INLINE static void setOutput() {
		DDR{{port}} = 0xff;
	}
	ALWAYS_INLINE static void setInput() {
		DDR{{port}} = 0;
	}
	ALWAYS_INLINE static uint8_t read() {
		return PIN{{port}};
	}
	ALWAYS_INLINE static void write(uint8_t data) {
		PORT{{port}} = data;
	}
};
		%% endif

	%% endfor
%% endfor

}	// namespace {{target.family}}

}	// namespace xpcc


#endif
