// coding: utf-8
// ----------------------------------------------------------------------------
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Roboterclub Aachen e.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// ----------------------------------------------------------------------------

#ifndef XPCC_{{target.family | upper}}__GPIO_HPP
#define XPCC_{{target.family | upper}}__GPIO_HPP

#include "../../../device.hpp"
#include "gpio_define.h"
#include <xpcc/architecture/peripheral/gpio.hpp>

/**
 * Macros for backwards compatibility:
 */

#define	GPIO__IO(name, port, pin) \
typedef CONCAT3(::xpcc::{{target.family}}::Gpio, port, pin) name

#define	GPIO__OUTPUT(name, port, pin) \
typedef CONCAT3(::xpcc::{{target.family}}::GpioOutput, port, pin) name

#define	GPIO__INPUT(name, port, pin) \
typedef CONCAT3(::xpcc::{{target.family}}::GpioInput, port, pin) name

#define	GPIO__NIBBLE_LOW(name, port) \
typedef CONCAT(::xpcc::{{target.family}}::GpioLowNibble, port) name

#define	GPIO__NIBBLE_HIGH(name, port) \
typedef CONCAT(::xpcc::{{target.family}}::GpioHighNibble, port) name

#define	GPIO__PORT(name, port) \
typedef CONCAT(::xpcc::{{target.family}}::GpioPort, port) name


namespace xpcc
{
	namespace {{target.family}}
	{
		struct Gpio
		{
			/**
			 * \ingroup	{{target.family}}
			 */
			enum class Configuration : uint8_t
			{
				Floating,
				PullUp,
			};
			
			/**
			 * \ingroup	{{target.family}}
			 */
			enum class InputTrigger : uint8_t
			{
				LowLevel = 0b00,
				AnyChange = 0b01,
				FallingEdge = 0b10,
				RisingEdge = 0b11,
			};
		};

		/**
		 * Gpio OpenDrain template, which remaps the behavior of the Gpio pin to
		 * simulate an open-drain Output.
		 * This maps set() -> setOutput() and reset() -> setInput(Configuration::PullUp)
		 */
		template< class IO >
		struct GpioOpenDrain : Gpio
		{
			ALWAYS_INLINE static void set() {
				IO::setInput(Configuration::PullUp);
			}
			ALWAYS_INLINE static void reset() {
				IO::setOutput(::xpcc::Gpio::LOW);
			}
			ALWAYS_INLINE static void set(bool status) {
				if (status) { set(); }
				else { reset(); }
			}
			ALWAYS_INLINE static bool read() {
				return IO::read();
			}
		};

		/**
		 * Gpio Classes created from the XML Device File Gpio Description
		 */
%% for gpio in gpios
	%% set port = gpio.port | upper
	%% set pin  = gpio.id
			
	%% for type in ["Output", "Input", ""] 
		
		%% if type == "Output"
		struct GpioOutput{{port ~ pin}} : public Gpio, ::xpcc::GpioOutput
		%% elif type == "Input"
		struct GpioInput{{port ~ pin}} : public Gpio, ::xpcc::GpioInput
		%% elif type == ""
		struct Gpio{{port ~ pin}} : public Gpio, ::xpcc::GpioIO
		%% endif
		{
		%% if type in ["", "Output"]
			ALWAYS_INLINE static void setOutput(bool status) {
				set(status);
				setOutput();
			}

			ALWAYS_INLINE static void setOutput() {
				DDR{{port}} |= (1 << {{pin}});
			}

			ALWAYS_INLINE static void set() {
				PORT{{port}} |=  (1 << {{pin}});
			}
			
			ALWAYS_INLINE static void set(bool status) {
				if (status) { set(); }
				else { reset(); }
			}

			ALWAYS_INLINE static void reset() {
				PORT{{port}} &= ~(1 << {{pin}});
			}

			ALWAYS_INLINE static void toggle() {
				PORT{{port}} ^=  (1 << {{pin}});
			}
		%% endif
		%% if type in ["", "Input"]
			ALWAYS_INLINE static void setInput() {
				DDR{{port}} &= ~(1 << {{pin}});
			}

			ALWAYS_INLINE static void
			setInput(Configuration type) {
				setInput();
				if (type == Configuration::PullUp) {
					PORT{{port}} |= (1 << {{pin}});
				}
				else {
					PORT{{port}} &= ~(1 << {{pin}});
				}
			}

			ALWAYS_INLINE static bool read() {
				return (PIN{{port}} & (1 << {{pin}}));
			}
		%% for af in gpio.afs
			%% set af_id = af.id | int
		
			%% if af.type == "extint"
			
			{# Go home Atmel, you're drunk! #}
			%% set eicra = 'EICRA'
			%% set isc2 = ''
			
			%% if target.family == 'atmega' and target.name in ['8', '16', '32', '162', '8515', '8535']
			%% set eicra = 'MCUCR'
			%% if target.name == '162'
			%% set isc2 = 'EMCUCR'
			%% else
			%% set isc2 = 'MCUCSR'
			%% endif
			%% endif
			
			ALWAYS_INLINE static void enableExternalInterrupt(InputTrigger trigger) {
			%% if af_id < 4
			%% if isc2 != '' and af_id == 2
				{{isc2}} |= ((static_cast<uint8_t>(trigger) & 0b01) << ISC2);
			%% else
				{{eicra}} |= (static_cast<uint8_t>(trigger) << 2*{{af_id}});
			%% endif
			%% else
				EICRB |= (static_cast<uint8_t>(trigger) << 2*{{af_id - 4}});
			%% endif
#ifdef EIMSK
				EIMSK |= (1 << INT{{af_id}});
#elif defined GIMSK
				GIMSK |= (1 << INT{{af_id}});
#elif defined GICR
				GICR |= (1 << INT{{af_id}});
#else
#	error "Cannot find register for setting INT{{af_id}}!"
#endif
			}

			ALWAYS_INLINE static void disableExternalInterrupt() {
			%% if af_id < 4
			%% if isc2 != '' and af_id == 2
				{{isc2}} &= ~(1 << ISC2);
			%% else
				{{eicra}} &= ~(0x3 << 2*{{af_id}});
			%% endif
			%% else
				EICRB &= ~(0x3 << 2*{{af_id - 4}});
			%% endif
#ifdef EIMSK
				EIMSK &= ~(1 << INT{{af_id}});
#elif defined GIMSK
				GIMSK &= ~(1 << INT{{af_id}});
#elif defined GICR
				GICR &= ~(1 << INT{{af_id}});
#else
#	error "Cannot find register for clearing INT{{af_id}}!"
#endif
			}

			ALWAYS_INLINE static bool getExternalInterruptFlag() {
#ifdef EIFR
				return (EIFR & (1 << INTF{{af_id}}));
#elif defined GIFR
				return (GIFR & (1 << INTF{{af_id}}));
#else
#	error "Cannot find register for reading INTF{{af_id}}!"
#endif
			}

			ALWAYS_INLINE static void acknowledgeExternalInterruptFlag() {
#ifdef EIFR
				EIFR |= (1 << INTF{{af_id}});
#elif defined GIFR
				GIFR |= (1 << INTF{{af_id}});
#else
#	error "Cannot find register for setting INTF{{af_id}}!"
#endif
			}
			%% endif

			%% if af.type == "pcint"

			{# Go home Atmel, you're drunk! #}
			%% if target.family == 'attiny'
			%% if (target.name == '2313' or target.name == '4313') and af_id >= 11 and af_id <= 17
			%% set af_reg = 2
			%% elif (target.name == '20' or target.name == '40' or target.name == '1634') and af_id >= 12 and af_id <= 17
			%% set af_reg = 2
			%% endif
			%% else
			%% set af_reg = (af_id / 8) | int
			%% endif
			
			
			ALWAYS_INLINE static void enablePCInterrupt() {
				PCMSK{{af_reg}} |= (1 << PCINT{{af_id}});
#ifdef PCICR
				PCICR |= (1 << PCIE{{af_reg}});
#elif defined EIMSK
				EIMSK |= (1 << PCIE{{af_reg}});
#elif defined GIMSK
				GIMSK |= (1 << PCIE{{af_reg}});
#elif defined GICR
				GICR |= (1 << PCIE{{af_reg}});
#else
#	error "Cannot find register for setting PCIE{{af_reg}}!"
#endif
			}

			ALWAYS_INLINE static void disablePCInterrupt() {
				PCMSK{{af_reg}} &= ~(1 << PCINT{{af_id}});
				if (!PCMSK{{af_reg}}) {
#ifdef PCICR
					PCICR &= ~(1 << PCIE{{af_reg}});
#elif defined EIMSK
					EIMSK &= ~(1 << PCIE{{af_reg}});
#elif defined GIMSK
					GIMSK &= ~(1 << PCIE{{af_reg}});
#elif defined GICR
					GICR &= ~(1 << PCIE{{af_reg}});
#else
#	error "Cannot find register for clearing PCIE{{af_reg}}!"
#endif
				}
			}

			ALWAYS_INLINE static bool getPCInterruptFlag() {
#ifdef PCIFR
				return (PCIFR & (1 << PCIF{{af_reg}}));
#elif defined EIFR
				return (EIFR & (1 << PCIF{{af_reg}}));
#elif defined GIFR
				return (GIFR & (1 << PCIF{{af_reg}}));
#else
#	error "Cannot find register for reading PCIF{{af_reg}}!"
#endif
			}

			ALWAYS_INLINE static void acknowledgePCInterruptFlag() {
#ifdef PCIFR
				PCIFR |= (1 << PCIF{{af_reg}});
#elif defined EIFR
				EIFR |= (1 << PCIF{{af_reg}});
#elif defined GIFR
				GIFR |= (1 << PCIF{{af_reg}});
#else
#	error "Cannot find register for setting PCIF{{af_reg}}!"
#endif
			}

			%% endif

		%% endfor

		%% endif
		};

	%% endfor
%% endfor

%% for nibble in nibbles
	%% set port = nibble.port | upper

	%% for id in nibble.position
		%% if id == 0
		struct GpioLowNibble{{port}}
		{
			ALWAYS_INLINE static void setOutput() {
				DDR{{port}} |= 0x0f;
			}
			ALWAYS_INLINE static void setInput() {
				DDR{{port}} &= ~0x0f;
			}
			ALWAYS_INLINE static uint8_t read() {
				return (PIN{{port}} & 0x0f);
			}
			ALWAYS_INLINE static void write(uint8_t data) {
				PORT{{port}} = (data & 0x0f) | (PORT{{port}} & 0xf0);
			}
		};
		%% elif id == 1
		struct GpioHighNibble{{port}}
		{
			ALWAYS_INLINE static void setOutput() {
				DDR{{port}} |= 0xf0;
			}
			ALWAYS_INLINE static void setInput() {
				DDR{{port}} &= ~0xf0;
			}
			ALWAYS_INLINE static uint8_t read() {
				uint8_t data = PIN{{port}};
				return (data >> 4);
			}
			ALWAYS_INLINE static void write(uint8_t data) {
				data <<= 4;
				PORT{{port}} = data | (PORT{{port}} & 0x0f);
			}
		};
		%% endif

	%% endfor
%% endfor

%% for octet in octets
	%% set port = octet.port | upper

	%% for id in octet.position
		%% if id == 0
		struct GpioPort{{port}}
		{
			ALWAYS_INLINE static void setOutput() {
				DDR{{port}} = 0xff;
			}
			ALWAYS_INLINE static void setInput() {
				DDR{{port}} = 0;
			}
			ALWAYS_INLINE static uint8_t read() {
				return PIN{{port}};
			}
			ALWAYS_INLINE static void write(uint8_t data) {
				PORT{{port}} = data;
			}
		};
		%% endif

	%% endfor
%% endfor
	}
}


#endif
