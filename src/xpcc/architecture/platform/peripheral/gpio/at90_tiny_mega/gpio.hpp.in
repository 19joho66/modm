// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
{{ generation_block }}

#ifndef XPCC_{{target.family | upper}}_GPIO_HPP
#define XPCC_{{target.family | upper}}_GPIO_HPP

#include "../../../device.hpp"
#include "../../../type_ids.hpp"
#include "gpio_define.h"
#include <xpcc/architecture/peripheral/gpio.hpp>


namespace xpcc
{

namespace {{target.family}}
{

struct Gpio
{
	/**
	 * Each Pin can be configured in one of these states.
	 * Only available for Pins configured as inputs!
	 *
	 * @ingroup	{{target.family}}
	 */
	enum class
	Configuration : uint8_t
	{
		Floating,	///< The input pin is left floating
		PullUp,		///< The input pin is pulled to Vcc
	};

	/**
	 * Each External Interrupt can be configured to trigger on these conditions.
	 *
	 * @ingroup	{{target.family}}
	 */
	enum class
	InputTrigger : uint8_t
	{
		LowLevel = 0b00,	///< triggers **continously** during low level
		BothEdges = 0b01,	///< triggers on both rising and falling edge
		FallingEdge = 0b10,	///< triggers on falling edge
		RisingEdge = 0b11,	///< triggers on rising edge
	};

	/// @private
	/// @{
	static constexpr uint8_t
	i(Configuration config) { return static_cast<uint8_t>(config); }
	static constexpr uint8_t
	i(InputTrigger trigger) { return static_cast<uint8_t>(trigger); }
	/// @}
};

/**
 * Gpio OpenDrain template, which remaps the behavior of the Gpio pin to
 * simulate an open-drain Output (with internal pullups if you need it).
 * You must use this class for `SoftwareI2cMaster`!
 *
 * @see ::xpcc::SoftwareI2cMaster
 * @ingroup	{{target.family}}
 * @{
 */
template< class IO >
class GpioOpenDrain : Gpio
{
public:
	/// maps to `setInput(Configuration::Floating)` 
	ALWAYS_INLINE static void set() {
		IO::setInput(Configuration::Floating);
	}
	/// maps to `setOutput(::xpcc::Gpio::LOW)`
	ALWAYS_INLINE static void reset() {
		IO::setOutput(::xpcc::Gpio::LOW);
	}
	ALWAYS_INLINE static void set(bool status) {
		if (status) { set(); }
		else { reset(); }
	}
	ALWAYS_INLINE static bool read() {
		return IO::read();
	}
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda) {
		set();
	}
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl) {
		set();
	}
};
template< class IO >
class GpioOpenDrainWithPullUp : Gpio
{
public:
	/// maps to `setInput(Configuration::PullUp)` 
	ALWAYS_INLINE static void set() {
		IO::setInput(Configuration::PullUp);
	}
	/// maps to `setOutput(::xpcc::Gpio::LOW)`
	ALWAYS_INLINE static void reset() {
		IO::setOutput(::xpcc::Gpio::LOW);
	}
	ALWAYS_INLINE static void set(bool status) {
		if (status) { set(); }
		else { reset(); }
	}
	ALWAYS_INLINE static bool read() {
		return IO::read();
	}
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::SoftwareI2cMasterSda) {
		set();
	}
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::SoftwareI2cMasterScl) {
		set();
	}
};
/// @}

/**
 * Gpio Classes created from the XML Device File Gpio Description
 *
 * @ingroup	{{target.family}}
 */
%% for gpio in gpios
	%% set port = gpio.port | upper
	%% set pin  = gpio.id

	%% for type in ["Output", "Input", ""] 

		%% if type == "Output"
class GpioOutput{{port ~ pin}} : public Gpio, ::xpcc::GpioOutput
		%% elif type == "Input"
class GpioInput{{port ~ pin}} : public Gpio, ::xpcc::GpioInput
		%% elif type == ""
class Gpio{{port ~ pin}} : public Gpio, ::xpcc::GpioIO
		%% endif
{
public:
	static constexpr uint8_t pin = {{pin}};		///< the pin number of this GPIO
	static constexpr uint8_t mask = (1 << pin);	///< the mask of this GPIO

		%% if type in ["", "Output"]
	ALWAYS_INLINE static void setOutput(bool status) {
		set(status);
		setOutput();
	}

	ALWAYS_INLINE static void setOutput() {
		DDR{{port}} |= mask;
	}

	ALWAYS_INLINE static void set() {
		PORT{{port}} |= mask;
	}
	
	ALWAYS_INLINE static void set(bool status) {
		if (status) { set(); }
		else { reset(); }
	}

	ALWAYS_INLINE static void reset() {
		PORT{{port}} &= ~mask;
	}

	ALWAYS_INLINE static void toggle() {
		PORT{{port}} ^= mask;
	}
		%% endif
		%% if type in ["", "Input"]

	ALWAYS_INLINE static void configure(Configuration config) {
		if (config == Configuration::PullUp) {
			PORT{{port}} |= mask;
		}
		else {
			PORT{{port}} &= ~mask;
		}
	}

	ALWAYS_INLINE static void setInput() {
		DDR{{port}} &= ~mask;
	}

	ALWAYS_INLINE static void
	setInput(Configuration config) {
		setInput();
		configure(config);
	}

	ALWAYS_INLINE static bool read() {
		return (PIN{{port}} & mask);
	}
		%% if 'extint' in gpio
			%% set af_id = gpio.extint | int

				%# Go home Atmel, you're drunk!
				%% set eicra = 'EICRA'
				%% set isc2 = ''

				%% if target.family == 'atmega' and target.name in ['8', '16', '32', '162', '8515', '8535']
					%% set eicra = 'MCUCR'
					%% if target.name == '162'
						%% set isc2 = 'EMCUCR'
					%% else
						%% set isc2 = 'MCUCSR'
					%% endif
				%% endif

	ALWAYS_INLINE static void setInputTrigger(InputTrigger trigger) {
				%% if af_id < 4
					%% if isc2 != '' and af_id == 2
		{{isc2}} |= ((i(trigger) & 0b01) << ISC2);
					%% else
		{{eicra}} |= (i(trigger) << 2*{{af_id}});
					%% endif
				%% else
		EICRB |= (i(trigger) << 2*{{af_id - 4}});
				%% endif
	}

	ALWAYS_INLINE static void enableExternalInterrupt() {
#ifdef EIMSK
		EIMSK |= (1 << INT{{af_id}});
#elif defined GIMSK
		GIMSK |= (1 << INT{{af_id}});
#elif defined GICR
		GICR |= (1 << INT{{af_id}});
#else
#	error "Cannot find register for setting INT{{af_id}}!"
#endif
	}

	ALWAYS_INLINE static void disableExternalInterrupt() {
#ifdef EIMSK
		EIMSK &= ~(1 << INT{{af_id}});
#elif defined GIMSK
		GIMSK &= ~(1 << INT{{af_id}});
#elif defined GICR
		GICR &= ~(1 << INT{{af_id}});
#else
#	error "Cannot find register for clearing INT{{af_id}}!"
#endif
	}

	ALWAYS_INLINE static bool readExternalInterruptFlag() {
#ifdef EIFR
		return (EIFR & (1 << INTF{{af_id}}));
#elif defined GIFR
		return (GIFR & (1 << INTF{{af_id}}));
#else
#	error "Cannot find register for reading INTF{{af_id}}!"
#endif
	}

	ALWAYS_INLINE static void acknowledgeExternalInterruptFlag() {
#ifdef EIFR
		EIFR |= (1 << INTF{{af_id}});
#elif defined GIFR
		GIFR |= (1 << INTF{{af_id}});
#else
#	error "Cannot find register for setting INTF{{af_id}}!"
#endif
	}
		%% endif
		%% if 'pcint' in gpio
			%% set af_id = gpio.pcint | int

				%# Go home Atmel, you're drunk!
				%% if target.family == 'attiny'
					%% if (target.name == '2313' or target.name == '4313') and af_id >= 11 and af_id <= 17
						%% set af_reg = 2
					%% elif (target.name == '20' or target.name == '40' or target.name == '1634') and af_id >= 12 and af_id <= 17
						%% set af_reg = 2
					%% endif
				%% else
					%% set af_reg = (af_id / 8) | int
				%% endif


	ALWAYS_INLINE static void enablePCInterrupt() {
		PCMSK{{af_reg}} |= (1 << PCINT{{af_id}});
#ifdef PCICR
		PCICR |= (1 << PCIE{{af_reg}});
#elif defined EIMSK
		EIMSK |= (1 << PCIE{{af_reg}});
#elif defined GIMSK
		GIMSK |= (1 << PCIE{{af_reg}});
#elif defined GICR
		GICR |= (1 << PCIE{{af_reg}});
#else
#	error "Cannot find register for setting PCIE{{af_reg}}!"
#endif
	}

	ALWAYS_INLINE static void disablePCInterrupt() {
		PCMSK{{af_reg}} &= ~(1 << PCINT{{af_id}});
		if (!PCMSK{{af_reg}}) {
#ifdef PCICR
			PCICR &= ~(1 << PCIE{{af_reg}});
#elif defined EIMSK
			EIMSK &= ~(1 << PCIE{{af_reg}});
#elif defined GIMSK
			GIMSK &= ~(1 << PCIE{{af_reg}});
#elif defined GICR
			GICR &= ~(1 << PCIE{{af_reg}});
#else
#	error "Cannot find register for clearing PCIE{{af_reg}}!"
#endif
		}
	}

	ALWAYS_INLINE static bool readPCInterruptFlag() {
#ifdef PCIFR
		return (PCIFR & (1 << PCIF{{af_reg}}));
#elif defined EIFR
		return (EIFR & (1 << PCIF{{af_reg}}));
#elif defined GIFR
		return (GIFR & (1 << PCIF{{af_reg}}));
#else
#	error "Cannot find register for reading PCIF{{af_reg}}!"
#endif
	}

	ALWAYS_INLINE static void acknowledgePCInterruptFlag() {
#ifdef PCIFR
		PCIFR |= (1 << PCIF{{af_reg}});
#elif defined EIFR
		EIFR |= (1 << PCIF{{af_reg}});
#elif defined GIFR
		GIFR |= (1 << PCIF{{af_reg}});
#else
#	error "Cannot find register for setting PCIF{{af_reg}}!"
#endif
	}
		%% endif

		%% for af in gpio.afs
			{% if af.type == 'in' and type == 'Input' or
			 af.type == 'out' and type == 'Output' or
			 af.type == 'io' or type == "" %}

	/// Connect `{{port~pin}}` as `{{af.name}}` to `{{af.peripheral}}`.
	ALWAYS_INLINE static void
	connect(TypeId::{{ af.peripheral }}{{ af.name }}) {
				%% if af.name == "Txd"
		set();
				%% endif
				%% if af.type == "out"
		setOutput();
				%% elif af.type== "in"
		setInput();
				%% endif
	}
			%% endif
		%% endfor

		%% if type in ['', 'Output']
			%% for peripheral in   ['SoftwareSpiMasterMosi',
									'SoftwareSpiMasterSck']
	/// Connect to `{{peripheral}}`.
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::{{ peripheral }}) {
		setOutput();
	}
			%% endfor
		%% endif
		%% if type in ['', 'Input']
			%% for peripheral in ['SoftwareSpiMasterMiso']
	/// Connect to `{{peripheral}}`.
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::{{ peripheral }}) {
		setInput();
	}
			%% endfor
		%% endif
		%% for peripheral in []
	/// Connect to `{{peripheral}}`.
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::{{ peripheral }}) {}
		%% endfor
		%% endif
};

	%% endfor
%% endfor

%# Ports
%% for port in gpios | getPorts

/// @ingroup {{target.family}}
template< uint8_t START_PIN, uint8_t WIDTH >
class GpioPort{{port.name}} : public ::xpcc::GpioPort, public Gpio
{
	static_assert(START_PIN < {{port.startPin + port.width}}, "START_PIN too large, maximum {{port.startPin + port.width}}.");
	static_assert(WIDTH <= {{port.width}}, "WIDTH too large, maximum {{port.width}}.");
	static_assert(WIDTH > 0, "WIDTH should be at least 1.");
	static_assert(START_PIN + WIDTH <= {{port.startPin + port.width}}, "START_PIN + WIDTH too large, maximum {{port.startPin + port.width}}.");

	static constexpr uint8_t dataMask = (1 << WIDTH) - 1;
	static constexpr uint8_t portMask = dataMask << START_PIN;

public:
	static constexpr uint8_t width = WIDTH;

public:
	ALWAYS_INLINE static void setOutput() {
		DDR{{port.name}} |= portMask;
	}
	ALWAYS_INLINE static void setInput() {
		DDR{{port.name}} &= ~portMask;
	}
	ALWAYS_INLINE static uint8_t read() {
		uint8_t data = PIN{{port.name}} & portMask;
		return (data >> START_PIN);
	}
	ALWAYS_INLINE static void write(uint8_t data) {
		data <<= START_PIN;
		PORT{{port.name}} = (PORT{{port.name}} & ~portMask) | (data & portMask);
	}
};

template<>
class GpioPort{{port.name}}< 0, 8 > : public ::xpcc::GpioPort, public Gpio
{
public:
	static constexpr uint8_t width = 8;

public:
	ALWAYS_INLINE static void setOutput() {
		DDR{{port.name}} = 0xff;
	}
	ALWAYS_INLINE static void setInput() {
		DDR{{port.name}} = 0;
	}
	ALWAYS_INLINE static uint8_t read() {
		return PIN{{port.name}};
	}
	ALWAYS_INLINE static void write(uint8_t data) {
		PORT{{port.name}} = data;
	}
};

%% endfor

}	// namespace {{target.family}}

}	// namespace xpcc


#endif
