// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part for the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
{{ generation_block }}

#ifndef XPCC_XMEGA__GPIO_HPP
#define XPCC_XMEGA__GPIO_HPP

#include "../../../device.hpp"
#include "../../../core/avr/interrupts.hpp"
#include <xpcc/architecture/peripheral/gpio.hpp>


namespace xpcc
{

namespace xmega
{

struct Gpio
{
	/**
	 * Each Pin can be configured in one of these states.
	 * `OpenDrain` is the same as `WiredOr`, it is listed only for completion. 
	 *
	 * @ingroup	xmega
	 */
	enum class
	Configuration : uint8_t
	{
		Floating = PORT_OPC_TOTEM_gc,		///< floating on input
		PullDown = PORT_OPC_PULLDOWN_gc,	///< pull-down on input
		PullUp = PORT_OPC_PULLUP_gc,		///< pull-up on input
		BusKeeper = PORT_OPC_BUSKEEPER_gc,	///< keeps last input
		WiredOr = PORT_OPC_WIREDOR_gc,		///< pin is driven high on output, externally pulled down or floating on input
		WiredAnd = PORT_OPC_WIREDAND_gc,	///< pin is driven low on output, externally pulled down or floating on input
		WiredOrWithPullDown = PORT_OPC_WIREDORPULL_gc,	///< pin is driven high on output, internally pulled down on input
		WiredAndWithPullUp = PORT_OPC_WIREDANDPULL_gc,	///< pin is driven low on output, internally pulled high on input
		// this is just a shortcut, not everyone knows that OpenDrain is equal to WiredAnd
		OpenDrain = PORT_OPC_WIREDAND_gc,	///< shortcut for `WiredAnd` with external pullup (like in I2C)
		OpenDrainWithPullUp = PORT_OPC_WIREDANDPULL_gc,	///< shortcut for `WiredAnd` with internal pullup
	};
	
	/// Each pin can be configured to trigger an interrupt on these conditions.
	/// @ingroup	xmega
	enum class
	InputTrigger : uint8_t
	{
		LowLevel = PORT_ISC_LEVEL_gc,			///< triggers **continously** during low level
		BothEdges = PORT_ISC_BOTHEDGES_gc,		///< triggers on both rising and falling edge
		FallingEdge = PORT_ISC_FALLING_gc,		///< triggers on falling edge
		RisingEdge = PORT_ISC_RISING_gc,		///< triggers on rising edge
	};
	
	/// Indicates whether the pin is inverted in hardware.
	/// @ingroup xmega
	enum class
	Inverted : bool
	{
		No = false,
		Yes = true,
	};
	
};

{
	{

/**
 * Gpio Classes created from the XML Device File Gpio Description
 *
 * @ingroup	xmega
 */
%% for gpio in gpios
	%% set port = gpio.port | upper
	%% set pin  = gpio.id
			
	%% for type in ["Output", "Input", ""] 
		
		%% if type == "Output"
class GpioOutput{{port ~ pin}} : public Gpio, ::xpcc::GpioOutput
		%% elif type == "Input"
class GpioInput{{port ~ pin}} : public Gpio, ::xpcc::GpioInput
		%% elif type == ""
class Gpio{{port ~ pin}} : public Gpio, ::xpcc::GpioIO
		%% endif
{
public:
	static constexpr uint8_t pin = {{pin}};
	static constexpr PORT_t& port = PORT{{port}}; 
	static constexpr uint8_t mask = (1 << pin);
	static constexpr uint8_t eventChannelMuxInput = reinterpret_cast<uint16_t>(&getPort() - 0x0600)/4 + 0x50 + {{pin}};
	static constexpr uint16_t interrupt0VectorNumber = PORT{{port}}_INT0_vect_num;
	static constexpr uint16_t interrupt1VectorNumber = PORT{{port}}_INT1_vect_num;
	
	ALWAYS_INLINE static void configure(Configuration config,
										Inverted invert = Inverted::No) {
		PORT{{port}}_PIN{{pin}}CTRL = (PORT{{port}}_PIN{{pin}}CTRL & ~PORT_OPC_gm) | static_cast<uint8_t>(config);
		if (invert == Inverted::Yes) {
			PORT{{port}}_PIN{{pin}}CTRL |= PORT_INVEN_bm;
		}
		else {
			PORT{{port}}_PIN{{pin}}CTRL &= ~PORT_INVEN_bm;
		}
	}
		%% if type in ["", "Output"]
	ALWAYS_INLINE static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	
	ALWAYS_INLINE static void setOutput(Configuration config,
										Inverted invert = Inverted::No) {
		setOutput();
		configure(config, invert);
	}

	ALWAYS_INLINE static void setOutput() {
		PORT{{port}}_DIRSET = mask;
	}

	ALWAYS_INLINE static void set() {
		PORT{{port}}_OUTSET = mask;
	}
	
	ALWAYS_INLINE static void set(bool status) {
		if (status) { set(); }
		else { reset(); }
	}

	ALWAYS_INLINE static void reset() {
		PORT{{port}}_OUTCLR = mask;
	}

	ALWAYS_INLINE static void toggle() {
		PORT{{port}}_OUTTGL = mask;
	}
	
	ALWAYS_INLINE static void enableSlewRateLimit() {
		PORT{{port}}_PIN{{pin}}CTRL |= PORT_ISC_SRLEN_bm;
	}
	
	ALWAYS_INLINE static void disableSlewRateLimit() {
		PORT{{port}}_PIN{{pin}}CTRL &= ~PORT_ISC_SRLEN_bm;
	}
		%% endif
		%% if type in ["", "Input"]
	ALWAYS_INLINE static void setInput(Configuration config,
										Inverted invert = Inverted::No) {
		setInput();
		configure(config, invert);
	}

	ALWAYS_INLINE static void
	setInput() {
		 PORT{{port}}_DIRCLR = mask; 
	}

	ALWAYS_INLINE static bool read() {
		return (PORT{{port}}_IN & mask);
	}
	
	ALWAYS_INLINE static void setInputTrigger(InputTrigger trigger) {
		PORT{{port}}_PIN{{pin}}CTRL = (PORT{{port}}_PIN{{pin}}CTRL & ~PORT_ISC_gm) | static_cast<uint8_t>(trigger);
	}
	
	ALWAYS_INLINE static void enableExternalInterrupt0(InterruptLevel level) {
		PORT{{port}}_INT0MASK |= mask;
		PORT{{port}}_INTCTRL = (PORT{{port}}_INTCTRL & ~PORT_INT0LVL_gm) | (static_cast<uint8_t>(level) & PORT_INT0LVL_gm);
	}
	
	ALWAYS_INLINE static void enableExternalInterrupt1(InterruptLevel level) {
		PORT{{port}}_INT1MASK |= mask;
		PORT{{port}}_INTCTRL = (PORT{{port}}_INTCTRL & ~PORT_INT1LVL_gm) | ((static_cast<uint8_t>(level) << 2) & PORT_INT1LVL_gm);
	}

	ALWAYS_INLINE static void disableExternalInterrupt0() {
		PORT{{port}}_INT0MASK &= ~mask;
	}
	
	ALWAYS_INLINE static void disableExternalInterrupt1() {
		PORT{{port}}_INT1MASK &= ~mask;
	}

	ALWAYS_INLINE static bool getExternalInterruptFlag0() {
		return (PORT{{port}}_INTFLAGS & PORT_INT0IF_bm);
	}

	ALWAYS_INLINE static bool getExternalInterruptFlag1() {
		return (PORT{{port}}_INTFLAGS & PORT_INT1IF_bm);
	}

	ALWAYS_INLINE static void acknowledgeExternalInterruptFlag0() {
		PORT{{port}}_INTFLAGS |= PORT_INT0IF_bm;
	}

	ALWAYS_INLINE static void acknowledgeExternalInterruptFlag1() {
		PORT{{port}}_INTFLAGS |= PORT_INT1IF_bm;
	}
	
			%% if port in ['A', 'B', 'C', 'D', 'E', 'F']
	ALWAYS_INLINE static void enableInputBuffer() {
		PORT{{port}}_PIN{{pin}}CTRL &= ~PORT_ISC_gm;
	}
	
	/// disables the input buffer, when using this pin as analog input
	ALWAYS_INLINE static void disableInputBuffer() {
		PORT{{port}}_PIN{{pin}}CTRL = (PORT{{port}}_PIN{{pin}}CTRL & ~PORT_ISC_gm) | PORT_ISC_INPUT_DISABLE_gc;
	}
			%% endif
		%% endif
};

	%% endfor
%% endfor

%% for nibble in nibbles
	%% set port = nibble.port | upper

	%% for id in nibble.position
		%% if id == 0
struct GpioLowNibble{{port}} : public Gpio, ::xpcc::GpioNibble
{
	ALWAYS_INLINE static void setOutput() {
		PORT{{port}}_DIRSET = 0x0f;
	}
	ALWAYS_INLINE static void setInput() {
		PORT{{port}}_DIRCLR = 0x0f;
	}
	ALWAYS_INLINE static void configure(Configuration config,
										Inverted invert = Inverted::No) {
		PORTCFG.MPCMASK = 0x0f;
		PORT{{port}}_PIN0CTRL = static_cast<uint8_t>(config) | ((invert == Inverted::Yes) ? PORT_INVEN_bm : 0);
	}
	ALWAYS_INLINE static uint8_t read() {
		return (PORT{{port}}_IN & 0x0f);
	}
	ALWAYS_INLINE static void write(uint8_t data) {
		PORT{{port}}_OUTSET =   data & 0x0f;
		PORT{{port}}_OUTCLR = ~(data & 0x0f);
	}
};
		%% elif id == 1
struct GpioHighNibble{{port}} : public Gpio, ::xpcc::GpioNibble
{
	ALWAYS_INLINE static void setOutput() {
		PORT{{port}}_DIRSET = 0xf0;
	}
	ALWAYS_INLINE static void setInput() {
		PORT{{port}}_DIRCLR = 0xf0;
	}
	ALWAYS_INLINE static void configure(Configuration config,
										Inverted invert = Inverted::No) {
		PORTCFG.MPCMASK = 0xf0;
		PORT{{port}}_PIN7CTRL = static_cast<uint8_t>(config) | ((invert == Inverted::Yes) ? PORT_INVEN_bm : 0);
	}
	ALWAYS_INLINE static uint8_t read() {
		return ((PORT{{port}}_IN & 0xf0) >> 4);
	}
	ALWAYS_INLINE static void write(uint8_t data) {
		data <<= 4;
		PORT{{port}}_OUTSET =   data & 0xf0;
		PORT{{port}}_OUTCLR = ~(data & 0xf0);
	}
};
		%% endif

	%% endfor
%% endfor

%% for octet in octets
	%% set port = octet.port | upper

	%% for id in octet.position
		%% if id == 0
struct GpioPort{{port}} : public Gpio, ::xpcc::GpioOctet
{
	ALWAYS_INLINE static void setOutput() {
		PORT{{port}}_DIRSET = 0xff;
	}
	ALWAYS_INLINE static void setInput() {
		PORT{{port}}_DIRCLR = 0xff;
	}
	ALWAYS_INLINE static void configure(Configuration config,
										Inverted invert = Inverted::No) {
		PORTCFG.MPCMASK = 0xff;
		PORT{{port}}_PIN0CTRL = static_cast<uint8_t>(config) | ((invert == Inverted::Yes) ? PORT_INVEN_bm : 0);
	}
	ALWAYS_INLINE static uint8_t read() {
		return PORT{{port}}_IN;
	}
	ALWAYS_INLINE static void write(uint8_t data) {
		PORT{{port}}_OUT = data;
	}
};
		%% endif

	%% endfor
%% endfor

}

}


#endif
