// coding: utf-8
// ----------------------------------------------------------------------------
/* Copyright (c) 2011, Roboterclub Aachen e.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Roboterclub Aachen e.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef XPCC_STM32__GPIO_HPP
#define XPCC_STM32__GPIO_HPP

#include "../../../device.hpp"

static void
xpcc_gpio_enable()
{
	// FIXME: add possibility to switch individual clocks on and off
%% if target is stm32f2 or target is stm32f4
	// Enable GPIO clock
	// TODO adapt to actual pin count!
	// GPIOA-D
	RCC->AHB1ENR  |=   RCC_AHB1ENR_GPIOAEN   | RCC_AHB1ENR_GPIOBEN   | RCC_AHB1ENR_GPIOCEN   | RCC_AHB1ENR_GPIODEN;
	RCC->AHB1RSTR |=   RCC_AHB1RSTR_GPIOARST | RCC_AHB1RSTR_GPIOBRST | RCC_AHB1RSTR_GPIOCRST | RCC_AHB1RSTR_GPIODRST;
	RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOARST | RCC_AHB1RSTR_GPIOBRST | RCC_AHB1RSTR_GPIOCRST | RCC_AHB1RSTR_GPIODRST);
	// GPIOE-I
	RCC->AHB1ENR  |=   RCC_AHB1ENR_GPIOEEN   | RCC_AHB1ENR_GPIOFEN   | RCC_AHB1ENR_GPIOGEN   | RCC_AHB1ENR_GPIOHEN   | RCC_AHB1ENR_GPIOIEN;
	RCC->AHB1RSTR |=   RCC_AHB1RSTR_GPIOERST | RCC_AHB1RSTR_GPIOFRST | RCC_AHB1RSTR_GPIOGRST | RCC_AHB1RSTR_GPIOHRST | RCC_AHB1RSTR_GPIOIRST;
	RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST | RCC_AHB1RSTR_GPIOFRST | RCC_AHB1RSTR_GPIOGRST | RCC_AHB1RSTR_GPIOHRST | RCC_AHB1RSTR_GPIOIRST);
%% elif target is stm32f3
	// Enable GPIO clock
	// TODO adapt to actual pin count!
	// GPIOA-F
	RCC->AHBENR  |=
			  RCC_AHBENR_GPIOAEN
			| RCC_AHBENR_GPIOBEN
			| RCC_AHBENR_GPIOCEN
			| RCC_AHBENR_GPIODEN
			| RCC_AHBENR_GPIOEEN
			| RCC_AHBENR_GPIOFEN
			;
	RCC->AHBRSTR |=
			  RCC_AHBRSTR_GPIOARST
			| RCC_AHBRSTR_GPIOBRST
			| RCC_AHBRSTR_GPIOCRST
			| RCC_AHBRSTR_GPIODRST
			| RCC_AHBRSTR_GPIOFRST
			; // Reset value is 0, check if this can be left out.

	RCC->AHBRSTR &=
			~( RCC_AHBRSTR_GPIOARST
			 | RCC_AHBRSTR_GPIOBRST
			 | RCC_AHBRSTR_GPIOCRST
			 | RCC_AHBRSTR_GPIODRST
			 | RCC_AHBRSTR_GPIOFRST)
			;
%% endif
}



%% if output != 'gpio_enable.h'
#include <xpcc/architecture/driver/gpio.hpp>

/**
 * Macros for backwards compatibility:
 */
#define	GPIO__IO(name, port, pin) \
typedef CONCAT3(::xpcc::stm32::Gpio, port, pin) name

#define	GPIO__OUTPUT(name, port, pin) \
typedef CONCAT3(::xpcc::stm32::GpioOutput, port, pin) name

#define	GPIO__INPUT(name, port, pin) \
typedef CONCAT3(::xpcc::stm32::GpioInput, port, pin) name


namespace xpcc
{
	namespace stm32
	{
		struct Gpio
		{
			/**
			 * \ingroup	stm32f2
			 */
			enum PullType
			{
				FLOATING = 0x0,
				PULLUP = 0x1,
				PULLDOWN = 0x2,
			};

			/**
			 * \ingroup	stm32f2
			 */
			enum OutputType
			{
				PUSH_PULL = 0x0,
				OPEN_DRAIN = 0x1,
			};

			/**
			 * \ingroup	stm32f2
			 */
			enum OutputSpeed
			{
				SPEED_2MHZ = 0x0,
				SPEED_25MHZ = 0x1,
				SPEED_50MHZ = 0x1,
				SPEED_100MHZ = 0x3,
			};

			/**
			 * \ingroup	stm32f2
			 */
			// 0..7 = AFRL[31:0]
			// 8..15 = AFRH[31:0]
			enum AlternateFunction
			{
				AF_0 = 0x00,		///< System
				AF_1 = 0x01,		///< TIM1/2
				AF_2 = 0x02,		///< TIM3..5
				AF_3 = 0x03,		///< TIM8...11
				AF_4 = 0x04,		///< I2C1..3
				AF_5 = 0x05,		///< SPI1/2
				AF_6 = 0x06,		///< SPI3
				AF_7 = 0x07,		///< USART1..3
				AF_8 = 0x08,		///< USART4..6
				AF_9 = 0x09,		///< CAN1/2, TIM12..14
				AF_10 = 0x0a,		///< OTG_FS, OTG_HS
				AF_11 = 0x0b,		///< ETH
				AF_12 = 0x0c,		///< FSMC, SDIO, OTG_HS (configured as FS)
				AF_13 = 0x0d,		///< DCMI
				AF_14 = 0x0e,		///< Reserved
				AF_15 = 0x0f,		///< EVENTOUT
			};

			/**
			 * \ingroup	stm32
			 */
			static void
			enable()
			{
				xpcc_gpio_enable();
			}

			/**
			 * \ingroup	stm32
			 */
			static void
			disable()
			{
				// FIXME: Implement
			}

			/** \internal */
			template<unsigned int P, unsigned char N, bool = (N >= 8)>
			struct AlternateMode {
				ALWAYS_INLINE static void setMode(AlternateFunction m) {
					uint32_t tmp = reinterpret_cast<GPIO_TypeDef*>(P)->AFR[1];
					tmp &= ~(0xf << ((N - 8) * 4));
					tmp |= (m << ((N - 8) * 4));
					reinterpret_cast<GPIO_TypeDef*>(P)->AFR[1] = tmp;
				}
			};

			/** \internal */
			template<unsigned int P, unsigned char N>
			struct AlternateMode<P, N, false> {
				ALWAYS_INLINE static void setMode(AlternateFunction m) {
					uint32_t tmp = reinterpret_cast<GPIO_TypeDef*>(P)->AFR[0];
					tmp &= ~(0xf << (N * 4));
					tmp |= m << (N * 4);
					reinterpret_cast<GPIO_TypeDef*>(P)->AFR[0] = tmp;
				}
			};
		};

		/**
		 * Gpio Classes created from the XML Device File Gpio Description
		 */
%% for gpio in gpios
	%% set reg  = "GPIO" ~ gpio.port|upper
	%% set pin  = gpio.id

%% for type in ["Output", "Input", ""]
	%% set name = "Gpio" ~ type ~ gpio.port|upper ~ gpio.id

		/** \brief		{{gpio.port|upper}}{{gpio.id}} {{type}}
		 *  \ingroup	stm32
		 */
		struct {{name}} : Gpio
		{
	%% if type == "" or type == "Output"
			ALWAYS_INLINE static void setOutput(bool status) {
				set(status);
				setOutput();
			}

			ALWAYS_INLINE static void
			setOutput(OutputType out = PUSH_PULL,
				OutputSpeed speed = SPEED_50MHZ, PullType pull = FLOATING) { 
				{{reg}}->MODER   = ({{reg}}->MODER   & ~(0x3 << ({{pin}} * 2))) | (0x1 << ({{pin}} * 2));
				{{reg}}->OTYPER  = ({{reg}}->OTYPER  & ~(1 << {{pin}})) | (out << {{pin}});
				{{reg}}->OSPEEDR = ({{reg}}->OSPEEDR & ~(0x3 << ({{pin}} * 2))) | (speed << ({{pin}} * 2));
				{{reg}}->PUPDR   = ({{reg}}->PUPDR   & ~(0x3 << ({{pin}} * 2))) | (pull << ({{pin}} * 2));
			}

			ALWAYS_INLINE static void set() {
				{{reg}}->BSRRL = (1 << {{pin}});
			}

			ALWAYS_INLINE static void set(bool status) {
				if (status) { set(); }
				else { reset(); }
			}

			ALWAYS_INLINE static void reset() {
				{{reg}}->BSRRH = (1 << {{pin}});
			}

			ALWAYS_INLINE static void toggle() {
				if ({{reg}}->ODR & (1 << {{pin}})) { reset(); }
				else { set(); }
			}

			ALWAYS_INLINE static void
			setAlternateFunction(AlternateFunction alt, OutputType out,
				OutputSpeed speed = SPEED_50MHZ, PullType pull = FLOATING) {
				{{reg}}->MODER   = ({{reg}}->MODER   & ~(0x3 << ({{pin}} * 2))) | (0x2 << ({{pin}} * 2));
				AlternateMode<{{reg}}_BASE, {{pin}}>::setMode(alt);
				{{reg}}->OTYPER  = ({{reg}}->OTYPER  & ~(1 << {{pin}})) | (out << {{pin}});
				{{reg}}->OSPEEDR = ({{reg}}->OSPEEDR & ~(0x3 << ({{pin}} * 2))) | (speed << ({{pin}} * 2));
				{{reg}}->PUPDR   = ({{reg}}->PUPDR   & ~(0x3 << ({{pin}} * 2))) | (pull << ({{pin}} * 2));
			}
	%% endif
	%% if type == "" or type == "Input"
			ALWAYS_INLINE static void
			setInput(PullType type = FLOATING) {
				{{reg}}->MODER &= ~(0x3 << ({{pin}} * 2));
				{{reg}}->PUPDR = ({{reg}}->PUPDR & ~(0x3 << ({{pin}} * 2))) | (type << ({{pin}} * 2));
			}

			ALWAYS_INLINE static void
			setAnalogInput() {
				{{reg}}->MODER |= 0x3 << ({{pin}} * 2);
			}

			ALWAYS_INLINE static bool read() {
				return {{reg}}->IDR & (1 << {{pin}});
			}

			ALWAYS_INLINE static void
			setAlternateFunction(AlternateFunction alt, PullType pull) {
				{{reg}}->MODER   = ({{reg}}->MODER   & ~(0x3 << ({{pin}} * 2))) | (0x2 << ({{pin}} * 2));
				AlternateMode<{{reg}}_BASE, {{pin}}>::setMode(alt);
				{{reg}}->OTYPER  = ({{reg}}->OTYPER  & ~(1 << {{pin}})) | (PUSH_PULL << {{pin}});
				{{reg}}->OSPEEDR = ({{reg}}->OSPEEDR & ~(0x3 << ({{pin}} * 2))) | (SPEED_2MHZ << ({{pin}} * 2));
				{{reg}}->PUPDR   = ({{reg}}->PUPDR   & ~(0x3 << ({{pin}} * 2))) | (pull << ({{pin}} * 2));
			}
	%% endif
		};
%% endfor
%% endfor
	} /* namespace stm32 */
} /* xpcc */

%% endif

#endif // XPCC_STM32__GPIO_HPP
