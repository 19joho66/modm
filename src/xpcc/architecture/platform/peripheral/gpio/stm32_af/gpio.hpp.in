// coding: utf-8
// ----------------------------------------------------------------------------
/* Copyright (c) 2011, Roboterclub Aachen e.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Roboterclub Aachen e.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef XPCC_STM32__GPIO_HPP
#define XPCC_STM32__GPIO_HPP

#include "../../../device.hpp"

%% if target is stm32f3
// Define missing from the CMSIS lib
#define  RCC_AHBRSTR_GPIOERST ((uint32_t)(1<<21))
%% endif

static void
xpcc_gpio_enable()
{
	// FIXME: add possibility to switch individual clocks on and off
%% if target is stm32f2 or target is stm32f4
%%	set clock_tree = 'AHB1'
%% elif target is stm32f3
%%	set clock_tree = 'AHB'
%% endif

	// Enable GPIO clock
RCC->{{ clock_tree }}ENR  |=
%% for port in gpios|xpcc.values('port')|sort
%%	if not loop.last
	RCC_{{ clock_tree }}ENR_GPIO{{ port }}EN |
%%	else
	RCC_{{ clock_tree }}ENR_GPIO{{ port }}EN;
%%	endif
%% endfor

	// Reset GPIO peripheral
RCC->{{ clock_tree }}RSTR |=
%% for port in gpios|xpcc.values('port')|sort
%%	if not loop.last
	RCC_{{ clock_tree }}RSTR_GPIO{{ port }}RST |
%%	else
	RCC_{{ clock_tree }}RSTR_GPIO{{ port }}RST;
%%	endif
%% endfor

RCC->{{ clock_tree }}RSTR &= ~(
%% for port in gpios|xpcc.values('port')|sort
%%	if not loop.last
	RCC_{{ clock_tree }}RSTR_GPIO{{ port }}RST |
%%	else
	RCC_{{ clock_tree }}RSTR_GPIO{{ port }}RST);
%%	endif
%% endfor
}



%% if output != 'gpio_enable.h'
#include <xpcc/architecture/peripheral/gpio.hpp>
#include "../../../type_ids.hpp"

/**
 * Macros for backwards compatibility:
 */
#define	GPIO__IO(name, port, pin) \
typedef CONCAT3(::xpcc::stm32::Gpio, port, pin) name

#define	GPIO__OUTPUT(name, port, pin) \
typedef CONCAT3(::xpcc::stm32::GpioOutput, port, pin) name

#define	GPIO__INPUT(name, port, pin) \
typedef CONCAT3(::xpcc::stm32::GpioInput, port, pin) name


namespace xpcc
{
	namespace stm32
	{
		struct Gpio
		{
			/**
			 * \ingroup	stm32{{ target.family }}
			 */
			enum PullType
			{
				FLOATING = 0x0,
				PULLUP = 0x1,
				PULLDOWN = 0x2,
			};

			/**
			 * \ingroup	stm32{{ target.family }}
			 */
			enum OutputType
			{
				PUSH_PULL = 0x0,
				OPEN_DRAIN = 0x1,
			};

			/**
			 * \ingroup	stm32{{ target.family }}
			 */
			enum OutputSpeed
			{
		%% if target is stm32f2 or target is stm32f4
				SPEED_2MHZ   = 0x0,
				SPEED_25MHZ  = 0x1,
				SPEED_50MHZ  = 0x1,
				SPEED_100MHZ = 0x3,
		%% elif target is stm32f3
				SPEED_2MHZ  = 0x0,
				SPEED_10MHZ = 0x1,
				SPEED_50MHZ = 0x3,
		%% endif
			};

			/**
			 * \ingroup	stm32{{ target.family }}
			 */
			static void
			enable()
			{
				xpcc_gpio_enable();
			}

			/**
			 * \ingroup	stm32{{ target.family }}
			 */
			static void
			disable()
			{
				// FIXME: Implement
			}

		protected:
			//! I/O Direction Mode values for this specific pin.
			enum class Mode : uint32_t
			{
				Input  = 0x0,
				Output = 0x1,
				AlternateFunction = 0x2,
				Analog = 0x3,
				Mask   = 0x3,
			};

			/**
			 * \ingroup	stm32{{ target.family }}
			 */
			// 0..7 = AFRL[31:0]
			// 8..15 = AFRH[31:0]
			enum class AlternateFunction
			{
				AF_0 = 0x00,		///< System
				AF_1 = 0x01,		///< TIM1/2
				AF_2 = 0x02,		///< TIM3..5
				AF_3 = 0x03,		///< TIM8...11
				AF_4 = 0x04,		///< I2C1..3
				AF_5 = 0x05,		///< SPI1/2
				AF_6 = 0x06,		///< SPI3
				AF_7 = 0x07,		///< USART1..3
				AF_8 = 0x08,		///< USART4..6
				AF_9 = 0x09,		///< CAN1/2, TIM12..14
				AF_10 = 0x0a,		///< OTG_FS, OTG_HS
				AF_11 = 0x0b,		///< ETH
				AF_12 = 0x0c,		///< FSMC, SDIO, OTG_HS (configured as FS)
				AF_13 = 0x0d,		///< DCMI
				AF_14 = 0x0e,		///< Reserved
				AF_15 = 0x0f,		///< EVENTOUT
			};

			/** @name Enum Class To Integer helper functions.
			 * @{
			 */
						static constexpr uint32_t
			i(PullType pull) { return static_cast<uint32_t>(pull); }
			static constexpr uint32_t
			i(OutputType out) { return static_cast<uint32_t>(out); }
			static constexpr uint32_t
			i(OutputSpeed speed) { return static_cast<uint32_t>(speed); }
			static constexpr uint32_t
			i(Mode mode) { return static_cast<uint32_t>(mode); }
			static constexpr uint32_t
			i(AlternateFunction af) { return static_cast<uint32_t>(af); }
			 //! @}
		};

		/**
		 * Gpio Classes created from the XML Device File Gpio Description
		 */
%% for gpio in gpios
	%% set reg  = "GPIO" ~ gpio.port|upper
	%% set pin  = gpio.id

%% for type in ["Output", "Input", ""]
	%% set name = "Gpio" ~ type ~ gpio.port|upper ~ gpio.id

		/** \brief		{{gpio.port|upper}}{{gpio.id}} {{type}}
		 *  \ingroup	stm32
		 */
		struct {{name}} : Gpio
		{
		private:
			//! Pin Number.
			static constexpr uint8_t pin = {{pin}};
			//! Bitmask for registers that contain a 1bit value for every pin.
			static constexpr uint16_t mask  = 0x1 << pin;
			//! Bitmask for registers that contain a 2bit value for every pin.
			static constexpr uint32_t mask2 = 0x3 << (pin * 2);
			//! Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
			static constexpr uint8_t af_id  = pin / 8;
			//! Alternate Function offset. This depends on the af_id.
			static constexpr uint8_t af_offset =
									(af_id == 0)? (pin * 4) : ((pin - 8) * 4);
			//! Alternate Function register mask.
			static constexpr uint32_t af_mask  = 0xf << af_offset;


			//! TODO: Document
			ALWAYS_INLINE static void
			setAlternateFunction(AlternateFunction alt) {
				{{reg}}->MODER = ({{reg}}->MODER   & ~mask2)
									| (i(Mode::AlternateFunction) << (pin * 2));
				{{reg}}->AFR[af_id] = ({{reg}}->AFR[af_id] & ~af_mask)
										| (i(alt) << af_offset);
			}

			//! Enable Analog Mode which is needed to use this pin as an ADC input.
			ALWAYS_INLINE static void
			setAnalogInput() {
				{{reg}}->MODER |= i(Mode::Analog) << (pin * 2);
			}

		public:
	%% if type == "" or type == "Output"
			/** @name Output
			 * @{
			 */
			//! Initialze pin to be used as output and set initial state.
			ALWAYS_INLINE static void setOutput(bool status) {
				set(status);
				setOutput();
			}

			//! Initialze pin to be used as output.
			ALWAYS_INLINE static void
			setOutput(OutputType out = PUSH_PULL,
				OutputSpeed speed = SPEED_50MHZ, PullType pull = FLOATING) { 
				{{reg}}->MODER   = ({{reg}}->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
				{{reg}}->OTYPER  = ({{reg}}->OTYPER  & ~mask)  | (i(out) << pin);
				{{reg}}->OSPEEDR = ({{reg}}->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
				{{reg}}->PUPDR   = ({{reg}}->PUPDR   & ~mask2) | (i(pull)  << (pin * 2));
			}

			//! Set pin high.
			ALWAYS_INLINE static void set() {
		%% if target is stm32f2 or target is stm32f4
				{{reg}}->BSRRL = mask;
		%% elif target is stm32f3
				{{reg}}->BSRR = mask;
		%% endif
			}

			//! Set pin status: \b high (\c true), \b low (\c false).
			ALWAYS_INLINE static void set(bool status) {
				if (status) {
					set();
				} else {
					reset();
				}
			}

			//! Set pin low.
			ALWAYS_INLINE static void reset() {
		%% if target is stm32f2 or target is stm32f4
				{{reg}}->BSRRH = mask;
		%% elif target is stm32f3
				{{reg}}->BRR = mask;
		%% endif
			}

			//! Toggle pin.
			ALWAYS_INLINE static void toggle() {
				if ({{reg}}->ODR & mask) {
					reset();
				} else {
					set();
				}
			}
			//! @}

	%% endif
	%% if type == "" or type == "Input"
			/** @name Input
			 * @{
			 */
			//! Initialze pin to be used as input.
			ALWAYS_INLINE static void
			setInput(PullType pull = FLOATING) {
				{{reg}}->MODER   &= ~mask2;
				// reset output type and speed
				{{reg}}->OTYPER  &= ~mask;
				{{reg}}->OSPEEDR &= ~mask2;
				// set pullup type
				{{reg}}->PUPDR = ({{reg}}->PUPDR & ~mask2) | (i(pull) << (pin * 2));
			}

			//! Read digital input.
			ALWAYS_INLINE static bool read() {
				return {{reg}}->IDR & mask;
			}
			//! @}
	%% endif

			/** @name Connect Functions
			 * @{
			 */
	%% if type != "Output" and gpio.analog
	%% 	for analog_ip in gpio.analog|split(",")
			//! Connect to {{ analog_ip }}.
			ALWAYS_INLINE static void
			connect(TypeId::{{ analog_ip }} t) {
				(void) t; // avoid compiler warning
				setAnalogInput();
			}
	%% 	endfor
	%% endif

	%% for af in gpio.afs
	%%	set use = not (	(af.type|lower == "input"  and type == "Output") or
						(af.type|lower == "output" and type == "Input" ))
	%%	if use
			//! Connect {{name}} as {{af.description}} to {{af.peripheral}}.
			ALWAYS_INLINE static void
			connect(TypeId::{{ af.peripheral }} t) {
				(void) t; // avoid compiler warning
				setAlternateFunction(AlternateFunction::AF_{{ af.id }});
			}
	%%	endif
	%% endfor
			//! @}
		};
%% endfor
%% endfor

%# Ports
%% set ports = gpios|getPorts



	} /* namespace stm32 */
} /* xpcc */

%% endif

#endif // XPCC_STM32__GPIO_HPP
