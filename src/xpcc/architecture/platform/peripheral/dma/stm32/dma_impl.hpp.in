// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
* All Rights Reserved.
*
* The file is part of the xpcc library and is released under the 3-clause BSD
* license. See the file `LICENSE` for the full license governing this code.
*/
// ----------------------------------------------------------------------------

#ifndef XPCC_STM32_ADC{{ id }}_HPP
#	error 	"Don't include this file directly, use 'adc_{{ id }}.hpp' instead!"
#endif



void
xpcc::stm32::Dma{{ id }}::enable()
{
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA{{ id }}EN;
	// reset DMA
	RCC->AHB1RSTR |=  RCC_AHB1RSTR_DMA{{ id }}RST;
	RCC->AHB1RSTR &= ~RCC_AHB1RSTR_DMA{{ id }}RST;
}

void
xpcc::stm32::Dma{{ id }}::disable()
{
	RCC->AHB1ENR &= ~RCC_AHB1ENR_DMA{{ id }}EN;
}


%% for stream_id in range(0,8)
%% set stream = "DMA" ~ id ~ "_Stream" ~ stream_id

%% set pointer_types = [8, 16, 32]
%% for type in pointer_types
void
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::setMemorySource(uint{{type}}_t* address,
	MemoryIncrementMode inc, MemoryBurstTransfer transfer)
{
	//stop();
	static constexpr MemoryDataSize size = MemoryDataSize::Bit{{type}};
	static constexpr uint32_t mask =
				DMA_SxCR_MBURST_1 | DMA_SxCR_MBURST_0 |	// MemoryBurstTransfer
				DMA_SxCR_MSIZE_0  | DMA_SxCR_MSIZE_1  |	// MemoryDataSize
				DMA_SxCR_MINC                         |	// MemoryIncrementMode
				DMA_SxCR_DIR_0    | DMA_SxCR_DIR_1;    	// DataTransferDirection
	// a memory source could mean that either a memory-to-peripheral or a
	// memory-to-memory transfer is intended
	// we'll use the current transfer mode to determine what to do
	DataTransferDirection dir;
	if(getDataTransferDirection() == DataTransferDirection::MemoryToPeripheral) {
		dir = DataTransferDirection::MemoryToPeripheral;
		{{ stream }}->M0AR = reinterpret_cast<uint32_t>(address);

	} else {
		dir = DataTransferDirection::MemoryToMemory;
		{{ stream }}->PAR = reinterpret_cast<uint32_t>(address);
	}
	{{ stream }}->CR = ({{ stream }}->CR & ~mask)
		| static_cast<uint32_t>(transfer) | static_cast<uint32_t>(size)
		| static_cast<uint32_t>(inc)      | static_cast<uint32_t>(dir);
}

void
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::setPeripheralSource(uint{{type}}_t* address,
	PeripheralIncrementMode inc, PeripheralBurstTransfer transfer)
{
	//stop();
	static constexpr PeripheralDataSize size = PeripheralDataSize::Bit{{type}};
	static constexpr uint32_t mask =
				DMA_SxCR_PBURST_1 | DMA_SxCR_PBURST_0 |	// PeripheralBurstTransfer
				DMA_SxCR_PSIZE_0  | DMA_SxCR_PSIZE_1  |	// PeripheralDataSize
				DMA_SxCR_PINC                         |	// PeripheralIncrementMode
				DMA_SxCR_DIR_0    | DMA_SxCR_DIR_1;    	// DataTransferDirection
	static constexpr DataTransferDirection dir = DataTransferDirection::PeripheralToMemory;
	{{ stream }}->PAR = reinterpret_cast<uint32_t>(address);
	{{ stream }}->CR = ({{ stream }}->CR & ~mask)
		| static_cast<uint32_t>(transfer) | static_cast<uint32_t>(size)
		| static_cast<uint32_t>(inc)      | static_cast<uint32_t>(dir);
}
%% endfor

%% for type in pointer_types

void
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::setMemoryDestination(uint{{type}}_t* address,
	MemoryIncrementMode inc, MemoryBurstTransfer transfer)
{
	//stop();
	static constexpr MemoryDataSize size = MemoryDataSize::Bit{{type}};
	static constexpr uint32_t mask =
				DMA_SxCR_MBURST_1 | DMA_SxCR_MBURST_0 |	// MemoryBurstTransfer
				DMA_SxCR_MSIZE_0  | DMA_SxCR_MSIZE_1  |	// MemoryDataSize
				DMA_SxCR_MINC                         |	// MemoryIncrementMode
				DMA_SxCR_DIR_0    | DMA_SxCR_DIR_1;    	// DataTransferDirection
	// a memory source could mean that either a memory-to-peripheral or a
	// memory-to-memory transfer is intended
	// we'll use the current transfer mode to determine what to do
	DataTransferDirection dir;
	if(getDataTransferDirection() == DataTransferDirection::PeripheralToMemory) {
		dir = DataTransferDirection::PeripheralToMemory;
		{{ stream }}->M0AR = reinterpret_cast<uint32_t>(address);
	} else {
		dir = DataTransferDirection::MemoryToMemory;
		{{ stream }}->M0AR = reinterpret_cast<uint32_t>(address);
	}
	{{ stream }}->CR = ({{ stream }}->CR & ~mask)
		| static_cast<uint32_t>(transfer) | static_cast<uint32_t>(size)
		| static_cast<uint32_t>(inc)      | static_cast<uint32_t>(dir);
}


void
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::setPeripheralDestination(uint{{type}}_t* address,
	PeripheralIncrementMode inc, PeripheralBurstTransfer transfer)
{
	//stop();
	static constexpr PeripheralDataSize size = PeripheralDataSize::Bit{{type}};
	static constexpr uint32_t mask =
				DMA_SxCR_PBURST_1 | DMA_SxCR_PBURST_0 |	// PeripheralBurstTransfer
				DMA_SxCR_PSIZE_0  | DMA_SxCR_PSIZE_1  |	// PeripheralDataSize
				DMA_SxCR_PINC                         |	// PeripheralIncrementMode
				DMA_SxCR_DIR_0    | DMA_SxCR_DIR_1;    	// DataTransferDirection
	static constexpr DataTransferDirection dir = DataTransferDirection::MemoryToPeripheral;
	{{ stream }}->PAR = reinterpret_cast<uint32_t>(address);
	{{ stream }}->CR = ({{ stream }}->CR & ~mask)
		| static_cast<uint32_t>(transfer) | static_cast<uint32_t>(size)
		| static_cast<uint32_t>(inc)      | static_cast<uint32_t>(dir);
}
%% endfor

void
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::stop()
{
	{{ stream }}->CR &= ~DMA_SxCR_EN;
	while({{ stream }}->CR & DMA_SxCR_EN); // wait for stream to be stopped
}

void
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::configure(Channel channel,
	uint16_t sample_length, Priority priority, FlowControl flow)
{
	//stop();
	static constexpr uint32_t mask =
		DMA_SxCR_CHSEL_2 | DMA_SxCR_CHSEL_1 | DMA_SxCR_CHSEL_0 |	// Channel
		DMA_SxCR_PL_1    | DMA_SxCR_PL_0 |							// Priority
		DMA_SxCR_PFCTRL;											// FlowControl
	{{ stream }}->CR = ({{ stream }}->CR & ~mask)
		| static_cast<uint32_t>(channel) | static_cast<uint32_t>(priority)
		| static_cast<uint32_t>(flow);
	{{ stream }}->NDTR = sample_length;
}

void
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::start()
{
	{{ stream }}->CR |= DMA_SxCR_EN;
}

bool
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::isFinished()
{
	return !({{ stream }}->CR & DMA_SxCR_EN);
}

xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::DataTransferDirection
xpcc::stm32::Dma{{ id }}::Stream{{ stream_id }}::getDataTransferDirection()
{
	return static_cast<DataTransferDirection>(
		{{ stream }}->CR & (DMA_SxCR_DIR_0 | DMA_SxCR_DIR_1));
}

%% endfor
