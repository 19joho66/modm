// coding: utf-8
// ----------------------------------------------------------------------------
/* Copyright (c) 2009, Roboterclub Aachen e.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Roboterclub Aachen e.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// ----------------------------------------------------------------------------
{{ generation_block }}

#ifndef XPCC_{{target.family | upper}}__I2C_MASTER_HPP
#define XPCC_{{target.family | upper}}__I2C_MASTER_HPP

#include "../../../device.hpp"
#include "../../../drivers.hpp"
#include <xpcc/architecture/peripheral/i2c.hpp>

/// Error messages for linker.
extern void dummy_HIGH_DATARATE_IS_NOT_SUPPORTED(void);
extern void dummy_YOUR_DATARATE_IS_TOO_HIGH_FOR_CPU_FREQUENCY(void);

namespace xpcc
{
	namespace {{target.family}}
	{
		struct I2c
		{
			///@{
			/// GPIOs for the I2C pins
			%% for gpio in gpios
			typedef ::xpcc::{{target.family}}::Gpio{{ gpio.port }}{{ gpio.id }} {{ gpio.name | capitalize }};
			%% endfor
			///@}
		};
		
		/**
		 * @brief	Interrupt-driven I2C master module.
		 *
		 * Interrupts must be enabled.
		 * 
		 * @author Niklas Hauser
		 * @ingroup	{{target.family}}
		 */
		class I2cMaster : public ::xpcc::I2cMaster, public I2c
		{
		public:
			static ALWAYS_INLINE void
			initialize(DataRate rate=DataRate::Standard)
			{
				/*
				 * Sets the SCL frequency. The CPU clock frequency in the master must
				 * be at least 16 times higher than the SCL frequency. Note that
				 * slaves may prolong the SCL low period, thereby reducing the average
				 * TWI bus clock period. The SCL frequency is generated according to
				 * the following equation:
				 * 
				 * f_scl = f_cpu / (16 + 2 * twbr * 4 ^ twps)
				 *       = f_cpu / (16 + 2 * twbr * prescaler)
				 * 
				 * twbr = (f_cpu / f_scl - 16) / (2 * prescaler)
				 * 
				 * with:
				 *		twbr in range 0..255
				 *		twps in range 0..3
				 * 
				 *  twps | prescaler
				 * ------+-----------
				 *   0   |     1
				 *   1   |     4
				 *   2   |    16
				 *   3   |    64
				 * 
				 * Examples:
				 *   f_cpu  | f_scl |   settings
				 *   [MHz]  | [kHz] | twbr | twps
				 * ---------+-------+------+------
			 	 *  20.0000 |  400  |   17 |   0
				 *          |  100  |   92 |   0
				 *  16.0000 |  400  |   12 |   0
				 *          |  100  |   72 |   0
				 *  14.7456 |  400  |   10 |   0
				 *          |  100  |   65 |   0
				 *   8.0000 |  400  |    2 |   0
				 *          |  100  |   32 |   0
				 */
				uint32_t rawRate = static_cast<uint32_t>(rate);
				
				if (rawRate > 400000)
				{
					dummy_HIGH_DATARATE_IS_NOT_SUPPORTED();
				}
				
				if ((F_CPU / 16) < rawRate)
				{
					dummy_YOUR_DATARATE_IS_TOO_HIGH_FOR_CPU_FREQUENCY();
				}
				
				//static_assert(rawRate <= 400000, "The {{ target.family }} does not support High I2C baudrate.");
				//static_assert(rawRate * 16 >= F_CPU, "The CPU frequency must be 16x higher than I2C baudrate.");
				uint8_t baud = (F_CPU / static_cast<uint32_t>(rate) - 16) / 2;
				initializeWithBaud(baud);
			};
			
			static void
			reset(DetachCause cause=DetachCause::SoftwareReset);
			
		public:
			static bool
			start(xpcc::I2cDelegate *delegate);
			
			static bool
			startSync(xpcc::I2cDelegate *delegate);
			
			static Error
			getErrorState();
		
		private:
			static void
			initializeWithBaud(uint8_t baud);
		};
	}
}

#endif
