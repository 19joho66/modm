// coding: utf-8
// ----------------------------------------------------------------------------
/* Copyright (c) 2012, Roboterclub Aachen e.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Roboterclub Aachen e.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// ----------------------------------------------------------------------------

#include <util/twi.h>
#include "i2c_master.hpp"

// uncomment to debug your driver using simple uart
/*
#include <xpcc/architecture/platform.hpp>
#define DEBUG(x) xpcc::{{target.family}}::Uart0::write(x)
/*/
#define DEBUG(x)
//*/

// ----------------------------------------------------------------------------
namespace
{
	// parameter advice
	static xpcc::I2c::Operation nextOperation;
	
	// delegating
	static xpcc::I2cTransaction *delegate(0);
	static xpcc::I2cMaster::Error errorState(xpcc::I2cMaster::Error::NoError);

	// buffer management
	static xpcc::I2cTransaction::Starting starting;
	static xpcc::I2cTransaction::Writing writing;
	static xpcc::I2cTransaction::Reading reading;
}

// ----------------------------------------------------------------------------
/// TWI state machine interrupt handler
ISR(TWI_vect)
{
	switch(TW_STATUS)
	{
		case TW_START:
			// START has been transmitted
			// Fall through...
		case TW_REP_START:
			{
				DEBUG('s');
				// REPEATED START has been transmitted

				starting.address = 0;
				starting.next = xpcc::I2c::Operation::Stop;
				delegate->starting(starting);
				uint8_t addressMode = xpcc::I2c::Write;

				switch (starting.next)
				{
					case xpcc::I2c::Operation::Read:
						addressMode = xpcc::I2c::Read;
						reading.length = 0;
						reading.next = xpcc::I2c::OperationAfterRead::Stop;
						delegate->reading(reading);
						nextOperation = static_cast<xpcc::I2c::Operation>(reading.next);
						break;
						
					case xpcc::I2c::Operation::Write:
						writing.length = 0;
						writing.next = xpcc::I2c::OperationAfterWrite::Stop;
						delegate->writing(writing);
						nextOperation = static_cast<xpcc::I2c::Operation>(writing.next);
						break;
						
					default:
					case xpcc::I2c::Operation::Stop:
						writing.length = 0;
						reading.length = 0;
						nextOperation = xpcc::I2c::Operation::Stop;
						break;
						
					case xpcc::I2c::Operation::Restart:
						writing.length = 0;
						reading.length = 0;
						nextOperation = xpcc::I2c::Operation::Restart;
						break;
				}
			
				// Load data register with TWI slave address
				TWDR = addressMode | (starting.address & 0xfe);
				// clear interrupt flag to send address
				TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
			}
			break;
			
		case TW_MT_SLA_ACK:
			// SLA+W has been transmitted and ACK received
			// Fall through...
		case TW_MT_DATA_ACK:
			// Data byte has been transmitted and ACK received
			if (writing.length > 0)
			{
				TWDR = *writing.buffer++;
				DEBUG('0' + writing.length);
				--writing.length;
				TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
				DEBUG('A');
			}
			else
			{
				switch (nextOperation)
				{
					case xpcc::I2c::Operation::Write:
						DEBUG('C');
						writing.length = 0;
						writing.next = xpcc::I2c::OperationAfterWrite::Stop;
						delegate->writing(writing);
						nextOperation = static_cast<xpcc::I2c::Operation>(writing.next);
						TWDR = *writing.buffer++;
						--writing.length;
						TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
						DEBUG('A');
						break;
						
					case xpcc::I2c::Operation::Restart:
						DEBUG('R');
						TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
						break;
						
					default:
						DEBUG('S');
						TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
						delegate->detaching(xpcc::I2c::DetachCause::NormalStop);
						delegate = 0;
						break;
				}
			}
			break;
			
		case TW_MR_DATA_ACK:
			*reading.buffer++ = TWDR;
			DEBUG('0' + reading.length);
			--reading.length;
			
			// Fall through...
		case TW_MR_SLA_ACK:
			// SLA+R has been transmitted and ACK received
			// See if last expected byte will be received ...
			if (reading.length > 0) {
				// Send ACK after reception
				TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN) | (1 << TWIE);
				DEBUG('a');
			}
			else {
				// Send NACK after next reception
				TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
				DEBUG('n');
			}
			break;
			
		case TW_MR_DATA_NACK:
			// Data byte has been received and NACK transmitted
			// => Transfer finished
			*reading.buffer++ = TWDR;
			DEBUG('0' + reading.length);
			--reading.length;
			
			switch (nextOperation)
			{
				case xpcc::I2c::Operation::Restart:
					DEBUG('r');
					TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
					break;
					
				default:
				case xpcc::I2c::Operation::Stop:
					DEBUG('S');
					TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
					delegate->detaching(xpcc::I2c::DetachCause::NormalStop);
					delegate = 0;
					break;
			}
			break;
			
		case TW_MT_SLA_NACK:	// SLA+W transmitted, NACK received
		case TW_MR_SLA_NACK:	// SLA+R transmitted, NACK received
			if (errorState != xpcc::{{target.family}}::I2cMaster::Error::NoError) {
				errorState = xpcc::{{target.family}}::I2cMaster::Error::AddressNack;
			}
			DEBUG('A');
		case TW_MT_DATA_NACK:	// data transmitted, NACK received
			if (errorState != xpcc::{{target.family}}::I2cMaster::Error::NoError) {
				errorState = xpcc::{{target.family}}::I2cMaster::Error::DataNack;
			}
			DEBUG('d');
			// generate a stop condition
			TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
		case TW_MT_ARB_LOST:	// arbitration lost in SLA+W or data
//		case TW_MR_ARB_LOST:	// arbitration lost in SLA+R or NACK
			if (errorState != xpcc::{{target.family}}::I2cMaster::Error::NoError) {
				errorState = xpcc::{{target.family}}::I2cMaster::Error::ArbitrationLost;
			}
			DEBUG('d');
		default:
			if (errorState != xpcc::{{target.family}}::I2cMaster::Error::NoError) {
				errorState = xpcc::{{target.family}}::I2cMaster::Error::Unknown;
			}
			DEBUG('r');
			xpcc::{{target.family}}::I2cMaster::reset(xpcc::I2c::DetachCause::ErrorCondition);
			break;
	}
	DEBUG('\n');
}

// ----------------------------------------------------------------------------
void
xpcc::{{target.family}}::I2cMaster::initialize(uint8_t twbr, Prescaler prescaler)
{
	// no reset, since we want to keep the delegate attached!
	TWBR = twbr;
	// No prescaler needed, unless we go significantly slower than standard Speed
	TWSR = static_cast<uint8_t>(prescaler);
	// Load data register with default content; release SDA
	TWDR = 0xff;
	// Enable TWI peripheral with interrupt disabled
	TWCR = (1 << TWEN);
}

void
xpcc::{{target.family}}::I2cMaster::reset(DetachCause cause)
{
	DEBUG('T');
	writing.length = 0;
	reading.length = 0;
	if (delegate) delegate->detaching(cause);
	delegate = 0;
}

xpcc::I2cMaster::Error
xpcc::{{target.family}}::I2cMaster::getErrorState()
{
	return errorState;
}

bool
xpcc::{{target.family}}::I2cMaster::start(xpcc::I2cTransaction *transaction)
{
	if (!delegate && transaction && transaction->attaching())
	{
		delegate = transaction;
		errorState = xpcc::{{target.family}}::I2cMaster::Error::NoError;
		DEBUG('Y');
		TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
		
		return true;
	}
	return false;
}

bool
xpcc::{{target.family}}::I2cMaster::startBlocking(xpcc::I2cTransaction *transaction)
{
	if (!delegate && transaction && transaction->attaching())
	{
		delegate = transaction;
		errorState = xpcc::{{target.family}}::I2cMaster::Error::NoError;
		DEBUG('Y');
		TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
		
		// the compiler generates out of order code here
		// so we introduce a memory barrier
		// to make sure, ::delegate is set _before_ entering a deadlock
		__asm__ volatile ("" ::: "memory");
		
		while (::delegate)
			;
		DEBUG('f');
		
		return true;
	}
	return false;
}
