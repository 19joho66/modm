// coding: utf-8
/* Copyright (c) 2013-2016, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
/**
 * @ingroup 	{{target.string}}
 * @defgroup	{{target.string}}_core Core
 */

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <reent.h>

// ----------------------------------------------------------------------------
%% if parameters.allocator == "newlib"
// __heap_start is set in the linker command file and is the end of
// statically allocated data (thus start of heap).
extern uint8_t __heap_start;
extern uint8_t __heap_end;

// Points to current end of the heap
uint8_t *__brkval = &__heap_start;

/* Support function. Adjusts end of heap to provide more memory to
 * memory allocator. Simple and dumb with no sanity checks.
 *
 *  struct _reent *r -- re-entrancy structure, used by newlib to
 *                      support multiple threads of operation.
 *  ptrdiff_t size   -- number of bytes to add.
 *                      Returns pointer to start of new heap area.
 *
 *  Note:  This implementation is not thread safe (despite taking a
 *         _reent structure as a parameter).
 *         Since the _reent struct is not used in the current implementation,
 *         the following messages must be suppressed.
 */
void *
_sbrk_r(struct _reent *r,  ptrdiff_t size)
{
	(void) r;
	// move heap pointer
	uint8_t *heap = __brkval;
	__brkval += size;

	if (__brkval >= &__heap_end) {
		// ERROR: out of memory!
		while (1) ;
	}

	//  Return pointer to start of new heap area.
	return heap;
}

// FIXME: "Unwrap" the malloc for newlib allocator
void *__real__malloc_r(struct _reent *r, size_t size);
void *__wrap__malloc_r(struct _reent *r, size_t size) {
	return __real__malloc_r(r, size);
}
void *__real__calloc_r(struct _reent *r, size_t size);
void *__wrap__calloc_r(struct _reent *r, size_t size) {
	return __real__calloc_r(r, size);
}
void *__real__realloc_r(struct _reent *r, void *p, size_t size);
void *__wrap__realloc_r(struct _reent *r, void *p, size_t size) {
	return __real__realloc_r(r, p, size);
}
void __real__free_r(struct _reent *r, void *p);
void __wrap__free_r(struct _reent *r, void *p) {
	__real__free_r(r, p);
}
%% endif
