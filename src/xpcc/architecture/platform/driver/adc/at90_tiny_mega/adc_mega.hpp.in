// coding: utf-8
/* Copyright (c) 2011, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------

#ifndef XPCC_ATMEGA_ADC_HPP
#define XPCC_ATMEGA_ADC_HPP

#include "../../../device.hpp"

#if defined (__AVR_ATmega64HVE__) || defined(__AVR_ATmega64HVE2__)
#	error "The ATmega64HVE2 is not supported by this ADC class."
#endif

{# The ATmega ADC module is incredibly fragmented, these defines help a tiny bit #}
%% if target.name in ['16', '32', '64'] and target.type in ['m1', 'c1']
	%% set adcsrb = 'AREFEN'
%% elif target.name in ['64', '128', '256', '644', '1284', '2564'] and target.type in ['rfa1', 'rfr2']
	%% set adcsrb = 'REFOK'
%% endif
%% if target.name in ['8', '16', '32'] and target.type in ['hva', 'hvab', 'hvabrevb']
	%% set vadc = 1
%% endif
%% if target.name in ['8', '128'] and target.type in ['a', None]
	%% set adfr = 1
%% endif
%% if (target.name in ['16', '32'] and target.type in ['u4']) or (target.name in ['640', '1280', '1281', '2560', '2561'] and target.type in [None]) or (target.name in ['64', '128', '256', '644', '1284', '2564'] and target.type in ['rfa1', 'rfr2'])
	%% set mux5 = 1
%% endif
%% if target.name in ['8', '48', '88', '168', '328'] and target.type in ['a', None, 'p', 'pa']
	%% set nomux4 = 1
%% endif
%% if target.name in ['16', '32', '8535'] and target.type in ['a', None]
	%% set sfior = 1
%% endif

namespace xpcc
{

namespace atmega
{

/**
 * Generic Analog/Digital-Converter module
 *
 * This class aims at providing a common interface to all the different
 * register layouts of the ADC modules in most ATmegas.
 * It takes into consideration restrictions and extensions in ADC
 * functionality and provides the appropriate methods to configure them.
 *
 * This class enables you to address and use a broader array of ATmegas
 * with similar ADC functionality without changing a single line of code.
 *
 * For best use of this class, check your device's datasheet for the
 * supported functionality.
 *
 * ADC clock frequency should be between 50 and 200 kHz for maximum
 * resolution. If less than 10-bits are needed the frequency can be higher.
 *
 * Synchronous mode (waits until the ADC is finished):
 * @code
 * Adc::initialize(Adc::Reference::Internal2V56, Adc::Prescaler::Div64);
 * ...
 * // read channel 2
 * uint16_t value = Adc::readChannel(2);
 * ...
 * @endcode
 *
 * Asynchronous mode:
 * @code
 * // start a new conversion on channel 3
 * Adc::startConversion(3);
 *
 * // do something useful while waiting for the result
 * while (!Adc::isFinished())
 *     ;
 *
 * // read the converted value
 * uint16_t value = Adc::getValue();
 * @endcode
 *
 * Alternatively you can use the AdcInterrupt class to attach a function
 * to the ADC Interrupt handler for true asynchonous mode.
 *
 * For a detailed example see the \c adc folder in the examples folder.
 *
 * @see 	AdcInterrupt
 * @author	Niklas Hauser
 * @author	Fabian Greif
 * @ingroup	atmega
 */
class Adc
{
public:
	enum class
	Reference : uint8_t
	{
	%% if adcsrb and adcsrb == 'AREFEN'
		ExternalARef = 0x20,
		InternalAVcc = 0x60,
		internalAVccNoCapacitor = 0x40,
		Internal2V56 = 0xe0,
		Internal2V56NoCapacitor = 0xc0,
	%% elif adcsrb and adcsrb == 'REFOK'
		InternalARef = 0,
		InternalAVddNoCapacitor = 0x40,
		Internal1V5NoCapacitor = 0x80,
		Internal1V6NoCapacitor = 0xc0,
	%% else
		ExternalARef = 0,
		InternalAVcc = 0x40,
		Internal2V56 = 0xe0,
		Internal1V1 = 0xc0,
	%% endif
	};

	enum class
	Prescaler : uint8_t
	{
		Div2 = 0x01,
		Div4 = 0x02,
		Div8 = 0x03,
		Div16 = 0x04,
		Div32 = 0x05,
		Div64 = 0x06,
		Div128 = 0x07,
	};

public:
//------------ ADMUX register -------------------------------------------------
	%% if not vadc
	/**
	 * voltage reference for the ADC
	 *
	 * The internal voltage reference options may not be used if an
	 * external reference voltage is being applied to the AREF pin.
	 */
	static inline void
	setReferenceVoltage(Reference referenceVoltage)
	{
	%% if acdsrb and adcsrb == 'AREFEN'
		ADCSRB = (ADCSRB & ~(1 << AREFEN)) | (static_cast<uint8_t>(referenceVoltage) & (1 << AREFEN));
	%% endif
		ADMUX = (ADMUX & ~0xc0) | (static_cast<uint8_t>(referenceVoltage) & 0xc0);
	}

	/**
	 * Change the presentation of the ADC conversion result
	 *
	 * Change will affect the ADC Data Register immediately, regardless
	 * of any ongoing conversions.
	 */
	static inline void
	setLeftAdjustResult()
	{
		ADMUX |= (1 << ADLAR);
	}
	/// Change the presentation of the ADC conversion result
	static inline void
	setRightAdjustResult()
	{
		ADMUX &= ~(1 << ADLAR);
	}
	%% endif
	/**
	 * Analog channel selection
	 *
	 * Selects which analog inputs are connected to the ADC.
	 * If this is changed during a conversion, the change will not go
	 * in effect until this conversion is complete.
	 */
	static inline bool
	setChannel(uint8_t channel)
	{
	%% if adcsrb and adcsrb == 'AREFEN'
		if (channel > 0x12) return false;
	%% elif mux5
		if (channel > 0x3f) return false;
		ADCSRB = (ADCSRB & ~(1<<MUX5)) | ((channel & 0x20) ? (1<<MUX5) : 0);
	%% elif nomux4 or vadc
		if (channel > 0x0f) return false;
	%% else
		if (channel > 0x1f) return false;
	%% endif
	%% if vadc
		VADMUX = (VADMUX & ~0x0f) | (channel & 0x0f);
	%% else
		ADMUX = (ADMUX & ~0x1f) | (channel & 0x1f);
	%% endif
		return true;
	}

	/// @return The analog channel connected to the ADC
	static inline uint8_t
	getChannel()
	{
	%% if vadc
		return (VADMUX & 0x0f);
	%% elif mux5
		return (ADMUX & 0x1f) | ((ADCSRB & (1<<MUX5)) ? 0x20 : 0);
	%% else
		return (ADMUX & 0x1f);
	%% endif
	}

//------------ ADCSRA register ------------------------------------------------
	/// Enables the ADC
	static ALWAYS_INLINE void
	enable()
	{
	%% if vadc
		VADCSR |= (1<<VADEN);
	%% else
		ADCSRA |= (1<<ADEN);
	%% endif
	}
	/// Disables the ADC
	static ALWAYS_INLINE void
	disable()
	{
	%% if vadc
		VADCSR &= ~(1<<VADEN);
	%% else
		ADCSRA &= ~(1<<ADEN);
	%% endif
	}
	/**
	 * In Single Conversion mode, this starts each conversion.
	 * In Free Running mode, this starts the first conversion.
	 */
	static ALWAYS_INLINE void
	startConversion()
	{
	%% if vadc
		VADCSR |= (1<<VADSC);
	%% else
		ADCSRA |= (1<<ADSC);
	%% endif
	}
	/// @return	`true` if the flag is set,
	///			`false` otherwise
	static inline bool
	getInterruptFlag()
	{
	%% if vadc
		return (VADCSR & (1<<VADCCIF));
	%% else
		return (ADCSRA & (1<<ADIF));
	%% endif
	}
	/// Clears the interrupt flag
	static inline void
	acknowledgeInterruptFlag()
	{
	%% if vadc
		VADCSR &= ~(1<<VADCCIF);
	%% else
		ADCSRA &= ~(1<<ADIF);
	%% endif
	}
	/// Enables the ADC Conversion Complete Interrupt
	static inline void
	enableInterrupt()
	{
	%% if vadc
		VADCSR |= (1<<VADCCIE);
	%% else
		ADCSRA |= (1<<ADIE);
	%% endif
	}
	/// Disables the ADC Conversion Complete Interrupt
	static inline void
	disableInterrupt()
	{
	%% if vadc
		VADCSR &= ~(1<<VADCCIE);
	%% else
		ADCSRA &= ~(1<<ADIE);
	%% endif
	}
	/**
	 * Set the division factor between the system clock frequency
	 * and the input clock to the ADC.
	 */
	static inline void
	setPrescaler(Prescaler prescaler)
	{
		ADCSRA = (ADCSRA & ~0x07) | static_cast<uint8_t>(prescaler);
	}

	%% if not vadc
	%% if adfr
	/**
	 * Enables free running mode
	 *
	 * The ADC will continously start conversions and provide the most
	 * recent result in the ADC register.
	 */
	static inline void
	enableFreeRunningMode()
	{
		ADCSRA |= (1<<ADFR);
	}
	/// Disables free running mode
	static inline void
	diableFreeRunningMode()
	{
		ADCSRA &= ~(1<<ADFR);
	}
	%% else
	/**
	 * Enable auto triggering of the ADC
	 *
	 * The ADC will start a conversion on a positive edge of the
	 * selected trigger signal.
	 * \see setAutoTriggerSource
	 */
	static inline void
	enableAutoTrigger()
	{
		ADCSRA |= (1<<ADATE);
	}
	/// Disable auto triggering of the ADC
	static inline void
	disableAutoTrigger()
	{
		ADCSRA &= ~(1<<ADATE);
	}
	%% endif
	%% endif


//------------ ADCSRB register ------------------------------------------------
	%% if not adfr and not vadc
	/**
	 * Selects which source will trigger an ADC conversion
	 *
	 * A conversion will be triggered by the rising edge of the
	 * selected Interrupt Flag. Note that switching from a trigger
	 * source that is cleared to a trigger source that is set, will
	 * generate a positive edge on the trigger signal.
	 * Set to 0 to enable Free Running Mode.
	 */
	static inline void
	setAutoTriggerSource(uint8_t source)
	{
	%% if acdsrb and adcsrb == 'AREFEN'
		if (source > 0x0d) return;
	%% else
		if (source > 0x07) return;
	%% endif
	%% if sfior
		SFIOR = (SFIOR & ~0xe0) | (source << 5);
	%% else
		ADCSRB = (ADCSRB & ~0x0f) | source;
	%% endif
	}
	%% endif

	%% if mux5 or (acdsrb and adcsrb == 'AREFEN')
	/**
	 * Enable the ADC High Speed mode
	 *
	 * Set this if you wish to convert with an ADC clock frequency
	 * higher than 200KHz.
	 * Clear this bit to reduce the power consumption of the ADC when
	 * the ADC clock frequency is lower than 200KHz.
	 */
	static inline void
	enableHighSpeedMode()
	{
		ADCSRB |= (1<<ADHSM);
	}
	/// Disable the ADC High Speed mode
	static inline void
	disableHighSpeedMode()
	{
		ADCSRB &= ~(1<<ADHSM);
	}
	%% endif

	%% if acdsrb and adcsrb == 'AREFEN'
	/// Source a 100uA current to the AREF pin
	static inline void
	enableCurrentSource()
	{
		ADCSRB |= (1<<ISRCEN);
	}
	/// Use AREF pin as Analog Reference pin.
	static inline void
	disableCurrentSource()
	{
		ADCSRB &= ~(1<<ISRCEN);
	}
	%% endif

	%% if acdsrb and adcsrb == 'REFOK'
	/**
	 * The analog functions of the ADC are powered from the AVDD domain.
	 * AVDD is supplied from an internal voltage regulator.
	 * Enabling the ADC will power-up the AVDD domain if not already
	 * requested by another functional group of the device.
	 * This method allows the user to monitor (poll) the status of the
	 * AVDD domain.
	 *
	 * @return `true` indicates that AVDD has been powered-up.
	 */
	static inline bool
	isAvddOk()
	{
		return (ADCSRB & (1<<AVDDOK));
	}
	/**
	 * The status of the internal generated reference voltage can be
	 * monitored through this bit.
	 * After enabling the ADC and setting the reference voltage, it
	 * will be available after a start-up delay.
	 *
	 * @return `true` which indicates that the internal generated
	 * reference voltage is approaching final levels.
	 */
	static inline bool
	isReferenceVoltageOk()
	{
		return (ADCSRB & (1<<REFOK));
	}
	/**
	 * The user can force a reset of the analog blocks by setting this
	 * without requesting a different channel. The analog blocks of the
	 * ADC will be reset to handle possible new voltage ranges. Such a
	 * reset phase is especially important for the gain amplifier. It
	 * could be temporarily disabled by a large step of its input common
	 * voltage leading to erroneous A/D conversion results.
	 */
	static inline void
	setAnalogChannelChange()
	{
		ADCSRB |= (1<<ACCH);
	}
	%% endif

//------------ ADC register ---------------------------------------------------
	static inline uint16_t
	getDataRegister()
	{
	%% if vadc
		return VADC;
	%% else
		return ADC;
	%% endif
	}

//-----------------------------------------------------------------------------
	%% if vadc
	/// Initialize and enable the A/D converter
	static inline void
	initialize()
	{
		enable();
	}
	%% else
	/// Initialize and enable the A/D converter
	static inline void
	initialize(Reference referenceVoltage,
			   Prescaler prescaler)
	{
		setReferenceVoltage(referenceVoltage);
		setPrescaler(prescaler);
		enable();
	}
	%% endif

	/// Correctly enables Free Running Mode
	static inline void
	freeRunningMode()
	{
	%% if adfr
		enableFreeRunningMode();
	%% else
		enableAutoTrigger();
		setAutoTriggerSource(0);
	%% endif
	}

	/**
	 * Read the value an analog channel
	 *
	 * A normal conversion takes 13 ADC clock cycles. With a clock frequency
	 * of for example 200 kHz a conversion therefore needs 65 microseconds.
	 * This time increases with a lower frequency.
	 */
	static inline uint16_t
	readChannel(uint8_t channel)
	{
		if (!startConversion(channel)) return 0;

		while (!getInterruptFlag()) {
			// wait until the conversion is finished
		}

		return getDataRegister();
	}

	/// Start a new conversion
	static inline bool
	startConversion(uint8_t channel)
	{
		if (!setChannel(channel)) return false;

		acknowledgeInterruptFlag();
		startConversion();

		return true;
	}

	/// Check if the conversion is finished
	static inline bool
	isFinished()
	{
		return getInterruptFlag();
	}

	/// the most recent 16bit result of the ADC conversion
	static inline uint16_t
	getValue()
	{
		return getDataRegister();
	}
};

}	// namespace atmega

}	// namespace xpcc

#endif	// XPCC_ATMEGA_ADC_HPP
