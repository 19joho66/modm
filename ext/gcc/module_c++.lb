#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (c) 2016-2017, Niklas Hauser
# Copyright (c) 2017-2018, Fabian Greif
# Copyright (c) 2018, Christopher Durand
#
# This file is part of the modm project.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# -----------------------------------------------------------------------------


def init(module):
    module.name = ":stdc++"
    module.description = """\
# C++ Standard Environment

Refines the C++ language to make it easier to use on embedded targets.
Depending on the module options, the compiler options are appended with either:

- `-fno-exceptions`: no C++ exceptions.
- `-fno-rtti`: no C++ run-time type information.

or:

- `-fexceptions`: with C++ exceptions.
- `-frtti`: with C++ run-time type information.

## AVR

A partial port of GCC 8 libstdc++ is provided:
See https://github.com/modm-io/avr-libstdcpp.

## ARM Cortex-M

Additional compiler options:

- `-fno-threadsafe-statics`: No thread-safe static initialization provided.
"""


def prepare(module, options):
    core = options[":target"].get_driver("core")["type"]
    is_avr = core.startswith("avr")
    is_cortex_m = core.startswith("cortex-m")
    if not (is_avr or is_cortex_m):
        return False

    if is_avr:
        module.add_option(
            BooleanOption(
                name="use_modm_assert", default=True,
                description="Assert on exception in stdlib. Set to False to save flash."))

    elif is_cortex_m:
        module.add_option(
            BooleanOption(
                name="exceptions", default=False,
                description=descr_exceptions))
        module.add_option(
            BooleanOption(
                name="rtti", default=False,
                description=descr_rtti))

    module.depends(":architecture:assert", ":architecture:memory", ":stdc")
    return True


def build(env):
    core = env[":target"].get_driver("core")["type"]
    is_avr = core.startswith("avr")
    is_cortex_m = core.startswith("cortex-m")

    env.substitutions = {"core": core}
    env.outbasepath = "modm/ext/gcc"
    env.template("cxxabi.cpp.in")

    if is_avr:
        env.collect(":build:path.include", "modm/ext/gcc/libstdc++/include")
        env.copy("libstdc++", ignore=env.ignore_files("*.lb", "*.md", "*.in", "examples"))
        env.template("assert.cpp.in", "assert.cpp")
        env.copy("newdelete_avr.cpp", "newdelete.cpp")

    elif is_cortex_m:
        env.copy("newdelete_cortex.cpp", "newdelete.cpp")

    # Compilation flags
    env.collect(":build:cxxflags", "-fuse-cxa-atexit", "-fno-threadsafe-statics")
    if env.get("exceptions", False):
        env.collect(":build:cxxflags", "-fexceptions", "-funwind-tables")
    else:
        env.collect(":build:cxxflags", "-fno-exceptions", "-fno-unwind-tables")
    if env.get("rtti", False):
        env.collect(":build:cxxflags", "-frtti")
    else:
        env.collect(":build:cxxflags", "-fno-rtti")


# ============================ Option Descriptions ============================

descr_exceptions = """# C++ Exceptions

Enables the full use of C++ exception handling.

!!! warning "Check your code size"
    The inclusion of the stack unwind tables will increase your code size quite
    a bit. Check whether your target has enough memory for this!
"""

descr_rtti = """# C++ Runtime Type Information

Enables the full use of C++ runtime type information.

!!! warning "Check your code size"
    The inclusion of the RTTI information will increase your code size quite a
    bit. Check whether your target has enough memory for this!
"""
